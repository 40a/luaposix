specify posix/sys/stat:
- before:
    st = require "posix.sys.stat"

    S_IRWXU, S_IRWXG, S_IRWXO = st.S_IRWXU, st.S_IRWXG, st.S_IRWXO
    S_ISBLK, S_ISCHR, S_ISDIR, S_ISFIFO, S_ISREG, S_ISLNK, S_ISSOCK =
      st.S_ISBLK, st.S_ISCHR, st.S_ISDIR, st.S_ISFIFO, st.S_ISREG, st.S_ISLNK, st.S_ISSOCK

    dir = posix.mkdtemp (template)
    posix.mkdir (dir .. "/subdir")
    posix.link ("subdir", dir .. "/soft", true)
    touch (dir .. "/file")
    posix.link (dir .. "/file", dir .. "/hard")
    posix.link ("no such destination", dir .. "/dangling", true)
    posix.mkfifo (dir .. "/fifo")

- after:
    rmtmp (dir)


- describe lstat:
  - before:
      # choose a format without seconds, that won't cause a race condition
      fmt = "%b %d %H:%M"
      now = os.date (fmt)
      getegid, geteuid = posix.getegid, posix.geteuid

      lstat = st.lstat

  - context with bad arguments:
      badargs.diagnose (lstat, "(string)")

  - it returns a PosixStat:
      expect (prototype (lstat (dir .. "/file"))).to_be "PosixStat"
  - it fetches the device id:
      dev = lstat (dir .. "/file").st_dev
      expect (type (dev)).to_be "number"
      expect (dev >= 0).to_be (true)
      expect (dev).to_be (lstat (dir).st_dev)
  - it fetches the file inode:
      ino = lstat (dir .. "/file").st_ino
      expect (type (ino)).to_be "number"
      expect (ino >= 0).to_be (true)
      expect (ino).to_be (lstat (dir .. "/hard").st_ino)
      expect (ino).not_to_be (lstat (dir .. "/soft").st_ino)
  - context with file mode:
    - it fetches the file access mode:
        mode = lstat (dir).st_mode
        expect (type (mode)).to_be "number"
        expect (band (mode, S_IRWXU)).to_be (S_IRWXU)
    - it recognises directories:
        expect (S_ISBLK (lstat (dir).st_mode)).to_be (0)
        expect (S_ISCHR (lstat (dir).st_mode)).to_be (0)
        expect (S_ISDIR (lstat (dir).st_mode)).not_to_be (0)
        expect (S_ISFIFO (lstat (dir).st_mode)).to_be (0)
        expect (S_ISREG (lstat (dir).st_mode)).to_be (0)
        expect (S_ISLNK (lstat (dir).st_mode)).to_be (0)
        expect (S_ISSOCK (lstat (dir).st_mode)).to_be (0)
    - it recognises fifos:
        expect (S_ISBLK (lstat (dir .. "/fifo").st_mode)).to_be (0)
        expect (S_ISCHR (lstat (dir .. "/fifo").st_mode)).to_be (0)
        expect (S_ISDIR (lstat (dir .. "/fifo").st_mode)).to_be (0)
        expect (S_ISFIFO (lstat (dir .. "/fifo").st_mode)).not_to_be (0)
        expect (S_ISREG (lstat (dir .. "/fifo").st_mode)).to_be (0)
        expect (S_ISLNK (lstat (dir .. "/fifo").st_mode)).to_be (0)
        expect (S_ISSOCK (lstat (dir .. "/fifo").st_mode)).to_be (0)
    - it recognises regular files:
        expect (S_ISBLK (lstat (dir .. "/file").st_mode)).to_be (0)
        expect (S_ISCHR (lstat (dir .. "/file").st_mode)).to_be (0)
        expect (S_ISDIR (lstat (dir .. "/file").st_mode)).to_be (0)
        expect (S_ISFIFO (lstat (dir .. "/file").st_mode)).to_be (0)
        expect (S_ISREG (lstat (dir .. "/file").st_mode)).not_to_be (0)
        expect (S_ISLNK (lstat (dir .. "/file").st_mode)).to_be (0)
        expect (S_ISSOCK (lstat (dir .. "/file").st_mode)).to_be (0)
    - it recognises soft links:
        expect (S_ISBLK (lstat (dir .. "/soft").st_mode)).to_be (0)
        expect (S_ISCHR (lstat (dir .. "/soft").st_mode)).to_be (0)
        expect (S_ISDIR (lstat (dir .. "/soft").st_mode)).to_be (0)
        expect (S_ISFIFO (lstat (dir .. "/soft").st_mode)).to_be (0)
        expect (S_ISREG (lstat (dir .. "/soft").st_mode)).to_be (0)
        expect (S_ISLNK (lstat (dir .. "/soft").st_mode)).not_to_be (0)
        expect (S_ISSOCK (lstat (dir .. "/soft").st_mode)).to_be (0)
  - it fetches the number of links:
      expect (lstat (dir .. "/file").st_nlink).to_be (2)
      expect (lstat (dir .. "/soft").st_nlink).to_be (1)
      expect (lstat (dir .. "/hard").st_nlink).
        to_be (lstat (dir .. "/file").st_nlink)
      expect (lstat (dir .. "/subdir").st_nlink).to_be (2)
  - it fetches the owner id:
      expect (lstat (dir .. "/file").st_uid).to_be (geteuid ())
      expect (lstat (dir .. "/subdir").st_uid).to_be (geteuid ())
  - it fetches the owner group id:
      expect (lstat (dir .. "/file").st_gid).to_be (getegid ())
      expect (lstat (dir .. "/subdir").st_gid).to_be (getegid ())
  - it fetches the device special file id:
      pending "mknod not yet bound"
  - it fetches the file size:
      # skip directory size, which is system dependent
      expect (lstat (dir .. "/file").st_size).to_be (0)
      expect (lstat (dir .. "/soft").st_size).to_be (string.len ("subdir"))
      expect (lstat (dir .. "/hard").st_size).
        to_be (lstat (dir .. "/file").st_size)
  - it fetches the file access time:
      expect (os.date (fmt, lstat (dir .. "/file").st_atime)).to_be (now)
  - it fetches the file modification time:
      expect (os.date (fmt, lstat (dir .. "/file").st_mtime)).to_be (now)
  - it fetches the file change time:
      expect (os.date (fmt, lstat (dir .. "/file").st_ctime)).to_be (now)
  - it fetches the device block size:
      blksize = lstat (dir .. "/file").st_blksize
      expect (type (blksize)).to_be "number"
      expect (blksize > 0).to_be (true)
      expect (blksize).to_be (lstat (dir .. "/hard").st_blksize)
  - it fetches the number of blocks:
      blocks = lstat (dir .. "/file").st_blocks
      expect (type (blocks)).to_be "number"
      expect (blocks >= 0).to_be (true)
      expect (blocks).to_be (lstat (dir .. "/hard").st_blocks)


- describe umask:
  - before:
      lstat, umask = st.lstat, st.umask
      newmask = band (st.S_IWGRP, st.S_IRWXO)
      origmask = umask (newmask)
  - after:
      umask (origmask)

  - context with bad arguments:
      badargs.diagnose (umask, "(int)")

  - it returns current umask:
      expect (umask (0)).to_be (newmask)
      expect (umask (newmask)).to_be (0)
  - it controls the mode of newly created files:
      all = bor (st.S_IRWXU, st.S_IRWXG, st.S_IRWXO)
      xxx, mask = dir .. "/xxx", bor (st.S_IRWXO, st.S_IWGRP, st.S_IXGRP)
      umask (mask)
      touch (xxx)
      expect (band (lstat (xxx).st_mode, all)).to_be (bor (st.S_IRUSR, st.S_IWUSR, st.S_IRGRP))
      os.remove (xxx)
