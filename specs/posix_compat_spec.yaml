specify compat:
- before:
    init = function (M, fname)
      return M[fname], function (...) return badargs.format (fname, ...) end
    end


- describe creat:
  - before:
      creat = posix.creat

  - context with bad arguments: |
      badargs.diagnose (creat, "creat (string, string)")

      examples {
        ["it diagnoses argument #2 invalid mode"] = function ()
          expect (creat ("not/existing", "g+vv")).
            to_raise "bad argument #3 to 'open' (bad mode)"
        end
      }


- describe fnmatch:
  - before:
      fnmatch, FNM_PATHNAME, FNM_PERIOD =
        posix.fnmatch, posix.FNM_PATHNAME, posix.FNM_PERIOD

  - context with bad arguments:
      badargs.diagnose (fnmatch, "fnmatch (string, string, ?int)")

  - it matches a file path against itself:
      expect (fnmatch ("test", "test")).to_be (true)
  - "it matches * against any filename characters":
      expect (fnmatch ("tes*", "test")).to_be (true)
      expect (fnmatch ("tes*", "test2")).to_be (true)
      expect (fnmatch ("*t*", "test")).to_be (true)
  - "it matches ? against a single filename character":
      expect (fnmatch ("tes?", "test")).to_be (true)
      expect (fnmatch ("t???", "test")).to_be (true)
      expect (fnmatch ("tes?", "tes")).to_be (false)
      expect (fnmatch ("tes?", "test2")).to_be (false)
  - "it doesn't match path separators with FNM_PATHNAME":
      expect (fnmatch ("*test", "/test")).to_be (true)
      expect (fnmatch ("*test", "/test", FNM_PATHNAME)).to_be (false)
  - "it doesn't match periods with FNM_PERIOD":
      expect (fnmatch ("*test", ".test")).to_be (true)
      expect (fnmatch ("*test", ".test", FNM_PERIOD)).to_be (false)


- describe getgroup:
  - before:
      getgrgid, getgroup, getegid =
        posix.getgrgid, posix.getgroup, posix.getegid
      groot = getgrgid (0).gr_name

  - context with bad arguments:
      badargs.diagnose (posix.getgroup, "getgroup (?string|int)")

  - it returns a table for an existing group:
      expect (type (getgroup (groot))).to_be "table"
  - it fetches current group by default:
      expect (getgroup ()).to_equal (getgroup (getegid ()))
  - it fetches a group by gid:
      expect (getgroup (0).name).to_be (groot)
      expect (getgroup (0).gid).to_be (0)
      expect (type (getgroup (0).mem)).to_be "table"
  - it fetches a group by name:
      expect (getgroup (groot).name).to_be (groot)
      expect (getgroup (groot).gid).to_be (0)
      expect (type (getgroup (groot).mem)).to_be "table"


- describe getpasswd:
  - before:
      getenv, getgid, getpasswd, getuid =
        posix.getenv, posix.getgid, posix.getpasswd, posix.getuid
      user = getpasswd ((getenv "USER"), "name")
      root = getpasswd (0, "name")

  - context with bad arguments:
    - before:
        getpasswd, badarg = init (posix, "getpasswd")

    - 'it diagnoses argument #1 type not string, int or nil':
        expect (getpasswd (false)).
          to_raise (badarg (1, "?string|int", "boolean"))

  - it fetches the user uid:
      expect (getpasswd (user).uid).to_be (getuid ())
      expect (getpasswd (root, "uid")).to_be (0)
  - it fetches the user name:
      expect (getpasswd (user).name).to_be (user)
      expect (getpasswd (0, "name")).to_be (root)
      expect (getpasswd (root, "name")).to_be (root)
  - it fetches the user gid:
      expect (getpasswd (user).gid).to_be (getgid ())
      expect (getpasswd (0, "gid")).to_be (0)
      expect (getpasswd (root, "gid")).to_be (0)
  - it fetches the user password:
      expect (getpasswd (user).passwd).to_match.any_of {"x", "%*+"}
      expect (getpasswd (0, "passwd")).to_match.any_of {"x", "%*+"}
      expect (getpasswd (root, "passwd")).to_match.any_of {"x", "%*+"}
  - it fetches the user home directory:
      expect (getpasswd (user, "dir")).to_be (getenv "HOME")
  - it fetches the user shell:
      expect (getpasswd (user, "shell")).to_be (getenv "SHELL")
  - it fetches a subtable of named fields:
      expect ({getpasswd (user, "name", "shell", "dir")}).
        to_equal {user, getenv "SHELL", getenv "HOME"}
  - it fetches everything without an argument:
      t = getpasswd (user)
      for k, v in pairs (t) do
        expect (t[k]).to_be (getpasswd (user, k))
      end


- describe getpid:
  - before:
      getpid, badarg = init (posix, "getpid")

  # posix.getpid takes an optional string or table as its first
  # argument, followed by zero or more strings only if the first
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not table, string or nil':
        expect (getpid (false)).to_raise (badarg (1, "?table|string", "boolean"))
    - 'it diagnoses argument #1 string invalid': |
        expect (getpid ("fubar")).
          to_raise "bad argument #1 to 'getpid' (invalid option 'fubar')"
    - 'it diagnoses argument #2 type not string':
        expect (getpid ("ppid", false)).
          to_raise (badarg (2, "string", "boolean"))
    - it diagnoses too many arguments:
        expect (getpid ({}, false)).to_raise (badarg (2))


- describe gettimeofday:
  - before:
      gettimeofday = posix.gettimeofday

  - context with bad arguments:
      badargs.diagnose (gettimeofday, "gettimeofday ()")

  - it fetches the current epoch time:
      t, epoch = gettimeofday (), posix.time ()
      expect (t.sec).to_be (epoch)
      expect (type (t.usec)).to_be "number"
      expect (t.usec >= 0).to_be (true)


- describe hostid:
  - context with bad arguments:
      badargs.diagnose (posix.hostid, "()")


- describe isgraph:
  - before:
      isgraph = posix.isgraph

  - context with bad arguments:
      badargs.diagnose (isgraph, "isgraph (string)")

  - it returns true for successful tests:
      expect (isgraph 'a').to_be (true)
  - it returns false for failed tests:
      expect (isgraph ' ').to_be (false)


- describe isprint:
  - before:
      isprint = posix.isprint

  - context with bad arguments:
      badargs.diagnose (isprint, "isprint (string)")

  - it returns true for successful tests:
      expect (isprint 'a').to_be (true)
  - it returns false for failed tests:
      expect (isprint (string.char (0))).to_be (false)


- describe stat:
  - before:
      # choose a format without seconds, that won't cause a race condition
      fmt = "%b %d %H:%M"
      getegid, geteuid = posix.getegid, posix.geteuid
      stat, badarg = init (posix, "stat")

      dir = posix.mkdtemp (template)
      posix.mkdir (dir .. "/subdir")
      posix.link ("subdir", dir .. "/soft", true)
      touch (dir .. "/file")
      posix.link (dir .. "/file", dir .. "/hard")
      posix.link ("no such destination", dir .. "/dangling", true)
      posix.mkfifo (dir .. "/fifo")

  - after:
      rmtmp (dir)

  # posix.stat takes an optional string or table as its second
  # argument, followed by zero or more strings only if the second
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses missing argument #1':
        expect (stat ()).to_raise (badarg (1, "string"))
    - 'it diagnoses argument #1 type not string':
        expect (stat (false)).to_raise (badarg (1, "string", "boolean"))
    - 'it diagnoses argument #2 type not table, string or nil':
        expect (stat (".", false)).
          to_raise (badarg (2, "?table|string", "boolean"))
    - 'it diagnoses argument #2 string invalid': |
        expect (stat (".", "fubar")).
          to_raise "bad argument #2 to 'stat' (invalid option 'fubar')"
    - 'it diagnoses argument #3 type not string':
        expect (stat (".", "type", false)).
          to_raise (badarg (3, "string", "boolean"))
    - it diagnoses too many arguments:
        expect (stat (".", {}, false)).
          to_raise (badarg (3))

  - it fetches the file inode:
      expect (stat (dir .. "/hard").ino).to_be (stat (dir .. "/file").ino)
  - it fetches the file type:
      expect (stat (dir).type).to_be "directory"
      expect (stat (dir .. "/file", "type")).to_be "regular"
      expect (stat (dir .. "/soft", "type")).to_be "link"
      expect (stat (dir .. "/hard", "type")).to_be "regular"
  - it fetches the file size:
      # skip directory size, which is system dependent
      expect (stat (dir .. "/file").size).to_be (0)
      expect (stat (dir .. "/soft", "size")).to_be (string.len ("subdir"))
      expect (stat (dir .. "/hard", "size")).
        to_be (stat (dir .. "/file", "size"))
  - it fetches the file access time:
      expect (os.date (fmt, stat (dir .. "/file", "atime"))).
        to_be (os.date (fmt))
  - it fetches the file modification time:
      expect (os.date (fmt, stat (dir .. "/file", "mtime"))).
        to_be (os.date (fmt))
  - it fetches the file creation time:
      expect (os.date (fmt, stat (dir .. "/file", "ctime"))).
        to_be (os.date (fmt))
  - it fetches the file access mode:
      expect (stat (dir .. "/file").mode).to_match ("^[-rwx]+$")
      expect (stat (dir .. "/subdir", "mode")).to_match ("^[-rwx]+$")
  - it fetches the number of links:
      expect (stat (dir .. "/file").nlink).to_be (2)
      expect (stat (dir .. "/soft", "nlink")).to_be (1)
      expect (stat (dir .. "/hard", "nlink")).
        to_be (stat (dir .. "/file", "nlink"))
      expect (stat (dir .. "/subdir", "nlink")).to_be (2)
  - it fetches the owner id:
      expect (stat (dir .. "/file").uid).to_be (geteuid ())
      expect (stat (dir .. "/subdir", "uid")).to_be (geteuid ())
  - it fetches the owner group id:
      expect (stat (dir .. "/file").gid).to_be (getegid ())
      expect (stat (dir .. "/subdir", "gid")).to_be (getegid ())
  - it fetches a subtable of named fields:
      expect ({stat (dir .. "/file", "type", "size", "nlink")}).
        to_equal {"regular", 0, 2}
  - it fetches everything without an argument:
      t = stat (dir .. "/file")
      for k, v in pairs (t) do
        expect (t[k]).to_be (stat (dir .. "/file", k))
      end


- describe umask:
  - before:
      stat, umask = posix.stat, posix.umask
      saved = umask ()
      umask "rwxr-x---"

      dir = posix.mkdtemp (template)

  - after:
      rmtmp (dir)
      umask (saved)

  - context with bad arguments: |
      examples {
        ["it diagnoses argument #1 invalid mode"] = function ()
          expect (umask ("g+vv")).
            to_raise "bad argument #1 to 'umask' (bad mode)"
        end
      }

      badargs.diagnose (umask, "umask (?string)")

  - it returns current umask:
      expect (umask ()).to_be "rwxr-x---"
  - "it sets attributes with '='":
      expect (umask "a=r").to_be "r--r--r--"
  - "it adds attributes with '+'":
      expect (umask "g+w").to_be "rwxrwx---"
  - "it removes attributes with '-'":
      expect (umask "u-r").to_be "-wxr-x---"
  - it accepts comma separated attribute specifications:
      expect (umask "a+r,g+w,u-x").to_be "rw-rwxr--"
  - it controls the mode of newly created files:
      xxx, mode = dir .. "/xxx", "rw--w-r--"
      umask (mode)
      touch (xxx)
      expect (stat (xxx, "mode")).to_be (mode)
      os.remove (xxx)


- describe uname:
  - before:
      uname = posix.uname

  - context with bad arguments: |
      badargs.diagnose (uname, "uname (?string)")

      examples {
        ['it diagnoses bad specifier format options'] = function ()
          expect (uname ("foo %_")).
            to_error "bad argument #1 to 'uname' (invalid format option '_')"
        end
      }

  - it substitutes %n:
      expect (uname "%n").to_be (cmd_output "uname -n")
  - it substitutes %m:
      expect (uname "%m").to_be (cmd_output "uname -m")
  - it substitutes %r:
      expect (uname "%r").to_be (cmd_output "uname -r")
  - it outputs everything with no arguments:
      expect (uname ()).to_be (cmd_output "uname -s -n -r -v -m")
