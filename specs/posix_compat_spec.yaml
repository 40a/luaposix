specify compat:
- before:
    init = function (M, fname)
      return M[fname], function (...) return badargs.format (fname, ...) end
    end


- describe chmod:
  - before:
      chmod, stat = posix.chmod, posix.stat
      touch "xxx"
      chmod ("xxx", "rwxr-x---")
  - after:
      os.remove "xxx"

  - context with bad arguments: |
      examples {
        ["it diagnoses argument #2 invalid mode"] = function ()
          expect (chmod (".", "g+vv")).
            to_raise "bad argument #2 to 'chmod' (bad mode)"
        end
      }

      badargs.diagnose (chmod, "chmod (string, string)")

  - it sets file mode with longhand mode string:
      mode = "rw---xr--"
      expect (Emsg (chmod ("xxx", mode))).to_be ""
      expect (stat ("xxx", "mode")).to_be (mode)
  - "it sets attributes with '='":
      expect (Emsg (chmod ("xxx", "o=w"))).to_be ""
      expect (stat ("xxx", "mode")).to_be "rwxr-x-w-"
  - "it adds attributes with '+'":
      expect (Emsg (chmod ("xxx", "g+w"))).to_be ""
      expect (stat ("xxx", "mode")).to_be "rwxrwx---"
  - "it removes attributes with '-'":
      expect (Emsg (chmod ("xxx",  "u-r"))).to_be ""
      expect (stat ("xxx", "mode")).to_be "-wxr-x---"
  - it accepts comma separated attribute specifications:
      expect (Emsg (chmod ("xxx", "a+x,g+w,u-w"))).to_be ""
      expect (stat ("xxx", "mode")).to_be "r-xrwx--x"
  - it diagnoses missing files:
      os.remove "xxx"
      expect (Emsg (chmod ("xxx", "a=rwx"))).to_contain "No such file or directory"


- describe creat:
  - before:
      creat = posix.creat

  - context with bad arguments: |
      badargs.diagnose (creat, "creat (string, string)")

      examples {
        ["it diagnoses argument #2 invalid mode"] = function ()
          expect (creat ("not/existing", "g+vv")).
            to_raise "bad argument #2 to 'creat' (bad mode)"
        end
      }


- describe fnmatch:
  - before:
      fnmatch, FNM_PATHNAME, FNM_PERIOD =
        posix.fnmatch, posix.FNM_PATHNAME, posix.FNM_PERIOD

  - context with bad arguments:
      badargs.diagnose (fnmatch, "fnmatch (string, string, ?int)")

  - it matches a file path against itself:
      expect (fnmatch ("test", "test")).to_be (true)
  - "it matches * against any filename characters":
      expect (fnmatch ("tes*", "test")).to_be (true)
      expect (fnmatch ("tes*", "test2")).to_be (true)
      expect (fnmatch ("*t*", "test")).to_be (true)
  - "it matches ? against a single filename character":
      expect (fnmatch ("tes?", "test")).to_be (true)
      expect (fnmatch ("t???", "test")).to_be (true)
      expect (fnmatch ("tes?", "tes")).to_be (false)
      expect (fnmatch ("tes?", "test2")).to_be (false)
  - "it doesn't match path separators with FNM_PATHNAME":
      expect (fnmatch ("*test", "/test")).to_be (true)
      expect (fnmatch ("*test", "/test", FNM_PATHNAME)).to_be (false)
  - "it doesn't match periods with FNM_PERIOD":
      expect (fnmatch ("*test", ".test")).to_be (true)
      expect (fnmatch ("*test", ".test", FNM_PERIOD)).to_be (false)


- describe getgroup:
  - before:
      getgrgid, getgroup, getegid =
        posix.getgrgid, posix.getgroup, posix.getegid
      groot = getgrgid (0).gr_name

  - context with bad arguments:
      badargs.diagnose (posix.getgroup, "getgroup (?string|int)")

  - it returns a table for an existing group:
      expect (type (getgroup (groot))).to_be "table"
  - it fetches current group by default:
      expect (getgroup ()).to_equal (getgroup (getegid ()))
  - it fetches a group by gid:
      expect (getgroup (0).name).to_be (groot)
      expect (getgroup (0).gid).to_be (0)
      expect (type (getgroup (0).mem)).to_be "table"
  - it fetches a group by name:
      expect (getgroup (groot).name).to_be (groot)
      expect (getgroup (groot).gid).to_be (0)
      expect (type (getgroup (groot).mem)).to_be "table"


- describe getpasswd:
  - before:
      getenv, getgid, getpasswd, getuid =
        posix.getenv, posix.getgid, posix.getpasswd, posix.getuid
      user = getpasswd ((getenv "USER"), "name")
      root = getpasswd (0, "name")

  - context with bad arguments:
    - before:
        getpasswd, badarg = init (posix, "getpasswd")

    - 'it diagnoses argument #1 type not string, int or nil':
        expect (getpasswd (false)).
          to_raise (badarg (1, "?string|int", "boolean"))

  - it fetches the user uid:
      expect (getpasswd (user).uid).to_be (getuid ())
      expect (getpasswd (root, "uid")).to_be (0)
  - it fetches the user name:
      expect (getpasswd (user).name).to_be (user)
      expect (getpasswd (0, "name")).to_be (root)
      expect (getpasswd (root, "name")).to_be (root)
  - it fetches the user gid:
      expect (getpasswd (user).gid).to_be (getgid ())
      expect (getpasswd (0, "gid")).to_be (0)
      expect (getpasswd (root, "gid")).to_be (0)
  - it fetches the user password:
      expect (getpasswd (user).passwd).to_match.any_of {"x", "%*+"}
      expect (getpasswd (0, "passwd")).to_match.any_of {"x", "%*+"}
      expect (getpasswd (root, "passwd")).to_match.any_of {"x", "%*+"}
  - it fetches the user home directory:
      expect (getpasswd (user, "dir")).to_be (getenv "HOME")
  - it fetches the user shell:
      expect (getpasswd (user, "shell")).to_be (getenv "SHELL")
  - it fetches a subtable of named fields:
      expect ({getpasswd (user, "name", "shell", "dir")}).
        to_equal {user, getenv "SHELL", getenv "HOME"}
  - it fetches everything without an argument:
      t = getpasswd (user)
      for k, v in pairs (t) do
        expect (t[k]).to_be (getpasswd (user, k))
      end


- describe getpid:
  - before:
      getpid, badarg = init (posix, "getpid")

  # posix.getpid takes an optional string or table as its first
  # argument, followed by zero or more strings only if the first
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not table, string or nil':
        expect (getpid (false)).to_raise (badarg (1, "?table|string", "boolean"))
    - 'it diagnoses argument #1 string invalid': |
        expect (getpid ("fubar")).
          to_raise "bad argument #1 to 'getpid' (invalid option 'fubar')"
    - 'it diagnoses argument #2 type not string':
        expect (getpid ("ppid", false)).
          to_raise (badarg (2, "string", "boolean"))
    - it diagnoses too many arguments:
        expect (getpid ({}, false)).to_raise (badarg (2))


- describe gettimeofday:
  - before:
      gettimeofday = posix.gettimeofday

  - context with bad arguments:
      badargs.diagnose (gettimeofday, "gettimeofday ()")

  - it fetches the current epoch time:
      t, epoch = gettimeofday (), posix.time ()
      expect (t.sec).to_be (epoch)
      expect (type (t.usec)).to_be "number"
      expect (t.usec >= 0).to_be (true)


- describe hostid:
  - context with bad arguments:
      badargs.diagnose (posix.hostid, "()")


- describe isgraph:
  - before:
      isgraph = posix.isgraph

  - context with bad arguments:
      badargs.diagnose (isgraph, "isgraph (string)")

  - it returns true for successful tests:
      expect (isgraph 'a').to_be (true)
  - it returns false for failed tests:
      expect (isgraph ' ').to_be (false)


- describe isprint:
  - before:
      isprint = posix.isprint

  - context with bad arguments:
      badargs.diagnose (isprint, "isprint (string)")

  - it returns true for successful tests:
      expect (isprint 'a').to_be (true)
  - it returns false for failed tests:
      expect (isprint (string.char (0))).to_be (false)


- describe mkdir:
  - before:
      dir = posix.mkdtemp (template)
      chdir, mkdir = posix.chdir, posix.mkdir
      cwd = posix.getcwd ()

  - after:
      chdir (cwd)
      rmtmp (dir)

  - context with bad arguments:
      badargs.diagnose (mkdir, "mkdir (string)")

  - it creates the named directory:
      expect (Emsg (mkdir (dir .. "/subdir"))).not_to_contain "exists"
      expect (Emsg (chdir (dir .. "/subdir"))).not_to_contain "No such flle or directory"
  - it diagnoses already existing directory:
      expect (Emsg (mkdir (dir))).to_contain "exists"


- describe mkfifo:
  - before:
      dir    = posix.mkdtemp (template)
      mkfifo = posix.mkfifo

  - after:
      rmtmp (dir)

  - context with bad arguments:
      badargs.diagnose (mkfifo, "mkfifo (string)")

  - it creates the named fifo:
      expect (Emsg (mkfifo (dir .. "/fifo"))).not_to_contain "exists"
      expect (posix.stat (dir .. "/fifo").type).to_be "fifo"
  - it diagnoses already existing fifo:
      expect (Emsg (mkfifo (dir))).to_contain "exists"


- describe msgget:
  - before:
      msgget = posix.msgget
      EEXIST, IPC_CREAT, IPC_EXCL = posix.EEXIST, posix.IPC_CREAT, posix.IPC_EXCL

  - context with bad arguments:
      badargs.diagnose (msgget, "msgget (int, ?int, ?string)")

  - it creates a queue:
      if msgget then
        modestr = "rwxrwxrwx"
        mq, err, errnum = msgget (100, bor (IPC_CREAT, IPC_EXCL), modestr)
        if errnum == EEXIST then
          mq, err = msgget (100, 0, modestr)
        end
        expect (mq).not_to_be (nil)
        expect (err).to_be (nil)
      end


- describe open:
  # posix.open ignores the mode argument if flags does not include
  # O_CREAT, which `badargs.diagnose` can't express; ergo manual
  # checks here...
  - before:
      O_CREAT = posix.O_CREAT
      open, badarg = init (posix, "open")

  - 'it diagnoses missing argument #1':
      expect (open ()).to_raise (badarg (1, "string"))
  - 'it diagnoses argument #1 type not string':
      expect (open (false)).to_raise (badarg (1, "string", "boolean"))
  - 'it diagnoses missing argument #2':
      expect (open ("not/existing")).to_raise (badarg (2, "int"))
  - 'it diagnoses argument #2 type not int':
      expect (open ("not/existing", false)).
        to_raise (badarg (2, "int", "boolean"))
  - 'it diagnoses missing argument #3':
      expect (open ("not/existing", O_CREAT)).to_raise (badarg (3, "string"))
  - 'it diagnoses argument #3 type not string':
      expect (open ("not/existing", O_CREAT, false)).
        to_raise (badarg (3, "string", "boolean"))
  - 'it diagnoses argument #3 invalid mode': |
      expect (open ("not/existing", O_CREAT, "g+vv")).
        to_raise "bad argument #3 to 'open' (bad mode)"
  - 'it diagnoses too many arguments':
      expect (open ("not/existing", -1, "o-s", false)).to_raise (badarg (4))


- describe stat:
  - before:
      # choose a format without seconds, that won't cause a race condition
      fmt = "%b %d %H:%M"
      getegid, geteuid = posix.getegid, posix.geteuid
      stat, badarg = init (posix, "stat")

      dir = posix.mkdtemp (template)
      posix.mkdir (dir .. "/subdir")
      posix.link ("subdir", dir .. "/soft", true)
      touch (dir .. "/file")
      posix.link (dir .. "/file", dir .. "/hard")
      posix.link ("no such destination", dir .. "/dangling", true)
      posix.mkfifo (dir .. "/fifo")

  - after:
      rmtmp (dir)

  # posix.stat takes an optional string or table as its second
  # argument, followed by zero or more strings only if the second
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses missing argument #1':
        expect (stat ()).to_raise (badarg (1, "string"))
    - 'it diagnoses argument #1 type not string':
        expect (stat (false)).to_raise (badarg (1, "string", "boolean"))
    - 'it diagnoses argument #2 type not table, string or nil':
        expect (stat (".", false)).
          to_raise (badarg (2, "?table|string", "boolean"))
    - 'it diagnoses argument #2 string invalid': |
        expect (stat (".", "fubar")).
          to_raise "bad argument #2 to 'stat' (invalid option 'fubar')"
    - 'it diagnoses argument #3 type not string':
        expect (stat (".", "type", false)).
          to_raise (badarg (3, "string", "boolean"))
    - it diagnoses too many arguments:
        expect (stat (".", {}, false)).
          to_raise (badarg (3))

  - it fetches the file inode:
      expect (stat (dir .. "/hard").ino).to_be (stat (dir .. "/file").ino)
  - it fetches the file type:
      expect (stat (dir).type).to_be "directory"
      expect (stat (dir .. "/file", "type")).to_be "regular"
      expect (stat (dir .. "/soft", "type")).to_be "link"
      expect (stat (dir .. "/hard", "type")).to_be "regular"
  - it fetches the file size:
      # skip directory size, which is system dependent
      expect (stat (dir .. "/file").size).to_be (0)
      expect (stat (dir .. "/soft", "size")).to_be (string.len ("subdir"))
      expect (stat (dir .. "/hard", "size")).
        to_be (stat (dir .. "/file", "size"))
  - it fetches the file access time:
      expect (os.date (fmt, stat (dir .. "/file", "atime"))).
        to_be (os.date (fmt))
  - it fetches the file modification time:
      expect (os.date (fmt, stat (dir .. "/file", "mtime"))).
        to_be (os.date (fmt))
  - it fetches the file creation time:
      expect (os.date (fmt, stat (dir .. "/file", "ctime"))).
        to_be (os.date (fmt))
  - it fetches the file access mode:
      expect (stat (dir .. "/file").mode).to_match ("^[-rwx]+$")
      expect (stat (dir .. "/subdir", "mode")).to_match ("^[-rwx]+$")
  - it fetches the number of links:
      expect (stat (dir .. "/file").nlink).to_be (2)
      expect (stat (dir .. "/soft", "nlink")).to_be (1)
      expect (stat (dir .. "/hard", "nlink")).
        to_be (stat (dir .. "/file", "nlink"))
      expect (stat (dir .. "/subdir", "nlink")).to_be (2)
  - it fetches the owner id:
      expect (stat (dir .. "/file").uid).to_be (geteuid ())
      expect (stat (dir .. "/subdir", "uid")).to_be (geteuid ())
  - it fetches the owner group id:
      expect (stat (dir .. "/file").gid).to_be (getegid ())
      expect (stat (dir .. "/subdir", "gid")).to_be (getegid ())
  - it fetches a subtable of named fields:
      expect ({stat (dir .. "/file", "type", "size", "nlink")}).
        to_equal {"regular", 0, 2}
  - it fetches everything without an argument:
      t = stat (dir .. "/file")
      for k, v in pairs (t) do
        expect (t[k]).to_be (stat (dir .. "/file", k))
      end


- describe sysconf:
  - before:
      sysconf, badarg = init (posix, "sysconf")

  # posix.sysconf takes an optional string or table as its first
  # argument, followed by zero or more strings only if the first
  # argument was a string; since we can't express that with
  # `badargs.diagnose` do it all manually again...
  - context with bad arguments:
    - 'it diagnoses argument #1 type not table, string or nil':
        expect (sysconf (false)).to_raise (badarg (1, "?table|string", "boolean"))
    - 'it diagnoses argument #1 string invalid': |
        expect (sysconf ("fubar")).
          to_raise "bad argument #1 to 'sysconf' (invalid option 'fubar')"
    - 'it diagnoses argument #2 type not string':
        expect (sysconf ("ARG_MAX", false)).
          to_raise (badarg (2, "string", "boolean"))
    - it diagnoses too many arguments:
        expect (sysconf ({}, false)).to_raise (badarg (2))

  - it fetches the maximum number of exec arguments:
      expect (type (sysconf ().ARG_MAX)).to_be "number"
      expect (sysconf "ARG_MAX" >= 0).to_be (true)
  - it fetches the number processes per user:
      expect (type (sysconf ().CHILD_MAX)).to_be "number"
      expect (sysconf "CHILD_MAX" >= 0).to_be (true)
  - it fetches the number of clock ticks per second:
      expect (type (sysconf ().CLK_TCK)).to_be "number"
      expect (sysconf "CLK_TCK" >= 0).to_be (true)
  - it fetches the job control version:
      expect (type (sysconf ().JOB_CONTROL)).to_be "number"
      expect (sysconf "JOB_CONTROL" >= 0).to_be (true)
  - it fetches the maximum number of groups:
      expect (type (sysconf ().NGROUPS_MAX)).to_be "number"
      expect (sysconf "NGROUPS_MAX" >= 0).to_be (true)
  - it fetches the maximum number of open descriptors:
      expect (type (sysconf ().OPEN_MAX)).to_be "number"
      expect (sysconf "OPEN_MAX" >= 0).to_be (true)
  - it fetches the number of saved ids:
      expect (type (sysconf ().SAVED_IDS)).to_be "number"
      expect (sysconf "SAVED_IDS" >= 0).to_be (true)
  - it fetches the maximum number of open streams:
      expect (type (sysconf ().STREAM_MAX)).to_be "number"
      expect (sysconf "STREAM_MAX" >= 0).to_be (true)
  - it fetches the maximum length of a timezone name:
      expect (type (sysconf ().TZNAME_MAX)).to_be "number"
      expect (sysconf "TZNAME_MAX" >= 0).to_be (true)
  - "it fetches the POSIX.1 version":
      expect (type (sysconf ().VERSION)).to_be "number"
      expect (sysconf "VERSION" >= 0).to_be (true)
  - it fetches a subtable of named fields:
      expect ({sysconf ("VERSION", "ARG_MAX", "OPEN_MAX")}).
        to_equal {sysconf "VERSION", sysconf "ARG_MAX", sysconf "OPEN_MAX"}
  - it fetches everything without an argument:
      t = sysconf ()
      for k, v in pairs (t) do
        expect (t[k]).to_be (sysconf (k))
      end


- describe umask:
  - before:
      stat, umask = posix.stat, posix.umask
      saved = umask ()
      umask "rwxr-x---"

      dir = posix.mkdtemp (template)

  - after:
      rmtmp (dir)
      umask (saved)

  - context with bad arguments: |
      examples {
        ["it diagnoses argument #1 invalid mode"] = function ()
          expect (umask ("g+vv")).
            to_raise "bad argument #1 to 'umask' (bad mode)"
        end
      }

      badargs.diagnose (umask, "umask (?string)")

  - it returns current umask:
      expect (umask ()).to_be "rwxr-x---"
  - "it sets attributes with '='":
      expect (umask "a=r").to_be "r--r--r--"
  - "it adds attributes with '+'":
      expect (umask "g+w").to_be "rwxrwx---"
  - "it removes attributes with '-'":
      expect (umask "u-r").to_be "-wxr-x---"
  - it accepts comma separated attribute specifications:
      expect (umask "a+r,g+w,u-x").to_be "rw-rwxr--"
  - it controls the mode of newly created files:
      xxx, mode = dir .. "/xxx", "rw--w-r--"
      umask (mode)
      touch (xxx)
      expect (stat (xxx, "mode")).to_be (mode)
      os.remove (xxx)


- describe uname:
  - before:
      uname = posix.uname

  - context with bad arguments: |
      badargs.diagnose (uname, "uname (?string)")

      examples {
        ['it diagnoses bad specifier format options'] = function ()
          expect (uname ("foo %_")).
            to_error "bad argument #1 to 'uname' (invalid format option '_')"
        end
      }

  - it substitutes %n:
      expect (uname "%n").to_be (cmd_output "uname -n")
  - it substitutes %m:
      expect (uname "%m").to_be (cmd_output "uname -m")
  - it substitutes %r:
      expect (uname "%r").to_be (cmd_output "uname -r")
  - it outputs everything with no arguments:
      expect (uname ()).to_be (cmd_output "uname -s -n -r -v -m")
