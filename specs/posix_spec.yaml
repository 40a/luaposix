# Specl specifications for APIs in lposix.c
#
# Specifications are topographically sorted, with fundamental calls specified
# at the top of the file, and calls with dependencies on correct functioning
# of earlier specifications further down.
#
# If you get a series of failed expectations, fixing the earliest failures
# first will often clear up later failures automatically!

specify posix:
- before:
    init = function (M, fname)
      return M[fname], function (...) return badargs.format (fname, ...) end
    end

- describe version:
  - it is set:
      expect (posix.version).not_to_be (nil)


- describe abort:
  - context with bad arguments:
      badargs.diagnose (posix.abort, "()")


- describe euidaccess:
  - before: f = posix.euidaccess
  - context with bad arguments:
      badargs.diagnose (f, "euidaccess (string, string)")


- describe isgraph:
  - context with bad arguments:
      badargs.diagnose (posix.isgraph, "(string)")


- describe isprint:
  - context with bad arguments:
      badargs.diagnose (posix.isprint, "(string)")


- describe errno:
  - context with bad arguments:
      badargs.diagnose (posix.errno, "(?int)")


- describe set_errno:
  - context with bad arguments:
      badargs.diagnose (posix.set_errno, "(int)")


- describe getopt:
  - context with bad arguments:
      badargs.diagnose (posix.getopt, "(list, string, ?table, ?int, ?int)")


- describe pipeline:
  - before: f = posix.pipeline
  - context with bad arguments:
      badargs.diagnose (f, "pipeline (table, ?function)")


- describe pipeline_iterator:
  - before: f = posix.pipeline_iterator
  - context with bad arguments:
      badargs.diagnose (f, "pipeline_iterator (table, ?function)")


- describe pipeline_slurp:
  - before: f = posix.pipeline_slurp
  - context with bad arguments:
      badargs.diagnose (f, "pipeline_slurp (table, ?function)")


- describe spawn:
  - before: f = posix.spawn
  - context with bad arguments:
      badargs.diagnose (f, "spawn (string|table|function, string*)")


- describe timeradd:
  - before:
      tv1 = { sec = 2, usec = 123456 }
      tv2 = { sec = 1, usec = 876543 }
      f = posix.timeradd

  - context with bad arguments:
      badargs.diagnose (f, "timeradd (table, table)")

  - it adds both fields of a timerval:
      expect (f (tv1, tv2)).to_equal { sec = 3, usec = 999999 }
  - it carries overflow second:
      expect (f (tv2, tv2)).to_equal { sec = 3, usec = 753086 }
  - it does not require 'sec' field:
      expect (f (tv1, {usec = 876543})).to_equal { sec = 2, usec = 999999 }
      expect (f ({usec = 123456}, {usec = 876543})).to_equal { sec = 0, usec = 999999}
  - it does not require 'usec' field:
      expect (f (tv1, {sec = 1})).to_equal { sec = 3, usec = 123456 }
      expect (f ({sec = 2}, {sec = 1})).to_equal { sec = 3, usec = 0 }


- describe timercmp:
  - before:
      tv1 = { sec = 2, usec = 123456 }
      tv2 = { sec = 1, usec = 876543 }
      f = posix.timercmp

  - context with bad arguments:
      badargs.diagnose (f, "timercmp (table, table)")

  - it returns 0 if timers are equal:
      expect (f (tv1, tv1)).to_equal (0)
  - it returns positive integer if second timer is greater than first:
      expect (f (tv1, tv2) > 0).to_be (true)
  - it returns negative integer if first timer is greater than the second:
      expect (f (tv2, tv1) < 0).to_be (true)


- describe timersub:
  - before:
      tv1 = { sec = 2, usec = 876543 }
      tv2 = { sec = 1, usec = 123456 }
      f = posix.timersub

  - context with bad arguments:
      badargs.diagnose (f, "timersub (table, table)")

  - it subtracts both fields of a timerval:
      expect (f (tv1, tv2)).to_equal { sec = 1, usec = 753087 }
  - it carries overflow second:
      expect (f (tv2, tv1)).to_equal { sec = -2, usec = 246913 }
  - it does not require 'sec' field:
      expect (f (tv1, {usec = 123456})).to_equal { sec = 2, usec = 753087 }
      expect (f ({usec = 876543}, {usec = 123456})).
        to_equal { sec = 0, usec = 753087}
  - it does not require 'usec' field:
      expect (f (tv1, {sec = 1})).to_equal { sec = 1, usec = 876543 }
      expect (f ({sec = 2}, {sec = 1})).to_equal { sec = 1, usec = 0 }


- specify file descriptors:
  - describe fileno:
    - context with bad arguments:
        badargs.diagnose (posix.fileno, "(file)")


  - describe mkfifo:
    - context with bad arguments:
        badargs.diagnose (posix.mkfifo, "(string)")


  - describe rpoll:
    - context with bad arguments:
        badargs.diagnose (posix.rpoll, "(int, int)")


  - describe poll:
    - context with bad arguments:
        badargs.diagnose (posix.poll, "(table, ?int)")


  - describe open:
    # posix.open ignores the mode argument if flags does not include
    # O_CREAT, which `badargs.diagnose` can't express; ergo manual
    # checks here...
    - before:
        O_CREAT = posix.O_CREAT
        open, badarg = init (posix, "open")

    - 'it diagnoses missing argument #1':
        expect (open ()).to_raise (badarg (1, "string"))
    - 'it diagnoses argument #1 type not string':
        expect (open (false)).to_raise (badarg (1, "string", "boolean"))
    - 'it diagnoses missing argument #2':
        expect (open ("not/existing")).to_raise (badarg (2, "int"))
    - 'it diagnoses argument #2 type not int':
        expect (open ("not/existing", false)).
          to_raise (badarg (2, "int", "boolean"))
    - 'it diagnoses missing argument #3':
        expect (open ("not/existing", O_CREAT)).to_raise (badarg (3, "string"))
    - 'it diagnoses argument #3 type not string':
        expect (open ("not/existing", O_CREAT, false)).
          to_raise (badarg (3, "string", "boolean"))
    - 'it diagnoses argument #3 invalid mode': |
        expect (open ("not/existing", O_CREAT, "g+vv")).
          to_raise "bad argument #3 to 'open' (bad mode)"
    - 'it diagnoses too many arguments':
        expect (open ("not/existing", -1, "o-s", false)).to_raise (badarg (4))


  - describe close:
    - context with bad arguments:
        badargs.diagnose (posix.close, "(int)")


  - describe dup:
    - context with bad arguments:
        badargs.diagnose (posix.dup, "(int)")


  - describe dup2:
    - context with bad arguments:
        badargs.diagnose (posix.dup2, "(int, int)")


  - describe pipe:
    - before:
        pipe, read, write = posix.pipe, posix.read, posix.write

    - context with bad arguments:
        badargs.diagnose (pipe, "()")

    - it creates a pipe:
        pout, pin = pipe ()
        expect (pout > 0).to_be (true)
        expect (pin > 0).to_be (true)
    - it can buffer characters:
        pout, pin = pipe ()
        data = "test characters"
        write (pin, data)
        expect (read (pout, data:len ())).to_be (data)


  - describe read:
    - context with bad arguments:
        badargs.diagnose (posix.read, "(int, int)")


  - describe write:
    - context with bad arguments:
        badargs.diagnose (posix.write, "(int, string)")


  - describe fcntl:
    - before:
        F_GETLK, F_SETLK, F_SETLKW = posix.F_GETLK, posix.F_SETLK, posix.F_SETLKW
        F_RDLCK, F_WRLCK, F_UNLCK = posix.F_RDLCK, posix.F_WRLCK, posix.F_UNLCK
        SEEK_SET, SEEK_CUR, SEEK_END = posix.SEEK_SET, posix.SEEK_CUR, posix.SEEK_END

        fcntl, badarg = init (posix, "fcntl")

    # posix.fcntl diagnoses the third arg differently depending on
    # the value of `cmd`, which `diagnose_badargs` can't express; ergo
    # manual checks here...
    - context with bad arguments:
      - 'it diagnoses missing argument #1':
          expect (fcntl ()).to_raise (badarg (1, "int"))
      - 'it diagnoses argument #1 type not int':
          expect (fcntl (false)).to_raise (badarg (1, "int", "boolean"))
      - 'it diagnoses missing argument #2':
          expect (fcntl (-1)).to_raise (badarg (2, "int"))
      - 'it diagnoses argument #2 type not int':
          expect (fcntl (-1, false)).to_raise (badarg (2, "int", "boolean"))
      - 'it diagnoses missing argument #3 to F_GETLK':
          expect (fcntl (-1, F_GETLK)).to_raise (badarg (3, "table"))
      - 'it diagnoses argument #3 type to F_GETLK not table':
          expect (fcntl (-1, F_GETLK, false)).
            to_raise (badarg (3, "table", "boolean"))
      - 'it diagnoses argument #3 type to non-F_GETLK not int':
          expect (fcntl (-1, 0, false)).
            to_raise (badarg (3, "?int", "boolean"))
      - 'it diagnoses too many arguments':
          expect (fcntl (-1, F_GETLK, {}, false)).to_raise (badarg (4))
          expect (fcntl (-1, 0, -1, false)).to_raise (badarg (4))

    - it has all needed constants:
        expect (type (F_GETLK)).to_be "number"
        expect (type (F_SETLK)).to_be "number"
        expect (type (F_SETLKW)).to_be "number"
        expect (type (F_RDLCK)).to_be "number"
        expect (type (F_WRLCK)).to_be "number"
        expect (type (F_UNLCK)).to_be "number"
        expect (type (SEEK_SET)).to_be "number"
        expect (type (SEEK_CUR)).to_be "number"
        expect (type (SEEK_END)).to_be "number"

    - context when file locking:
      - before:
          mkstemp, open, close = posix.mkstemp, posix.open, posix.close
          fork, wait, errno = posix.fork, posix.wait, posix.errno
          O_RDWR, EAGAIN, EACCES = posix.O_RDWR, posix.EAGAIN, posix.EACCES
          P_CHILD = 0
          SUCCESS = 0
          fd, path = mkstemp "tmpXXXXXX"
          close (fd)
          parent_pid = posix.getpid "pid"

          query_lock = {
            l_type = F_RDLCK, l_whence = SEEK_SET, l_start = 0, l_len = 0,
          }
          write_lock = {
            l_type = F_WRLCK, l_whence = SEEK_SET, l_start = 0, l_len = 0,
          }
      - after:
          os.remove (path)

      - it checks whether lock is possible with F_GETLK:
          fd = open (path, O_RDWR)
          result = fcntl (fd, F_GETLK, query_lock)
          expect (result).to_be (SUCCESS)
          expect (query_lock.l_type).to_be (F_UNLCK)
          close (fd)
      - it can lock file with F_SETLK: |
          parent_fd = open (path, O_RDWR)
          result = fcntl (parent_fd, F_SETLK, write_lock)
          expect (result).to_be (SUCCESS)
          process = fork ()
          if process == P_CHILD then
            child_fd = open (path, O_RDWR)
            result = fcntl (child_fd, F_GETLK, query_lock)
            close (child_fd)
            -- (not sure how to expect () in subprocess)
            if result ~= SUCCESS then
              os.exit (10)
            elseif query_lock.l_pid ~= parent_pid then
              os.exit (11)
            else
              os.exit (12)
            end
          else
            _, _, exit_code = wait (process)
            expect (exit_code).to_be (12)
          end
          close (parent_fd)
      - it returns error if cannot lock file with F_SETLK: |
          parent_fd = open (path, O_RDWR)
          result = fcntl (parent_fd, F_SETLK, write_lock)
          expect (result).to_be (0)
          process = fork ()
          if process == P_CHILD then
            child_fd = open (path, O_RDWR)
            result = fcntl (child_fd, F_SETLK, write_lock)
            close (child_fd)
            -- (not sure how to expect () in subprocess)
            if result == SUCCESS then
              os.exit (10)
            elseif errno () ~= errno (EACCES) and errno () ~= errno (EAGAIN) then
              os.exit (11)
            else
              os.exit (12)
            end
          else
            _, _, exit_code = wait (process)
            expect (exit_code).to_be (12)
          end
          close (parent_fd)


  - describe lseek:
    - before:
        close, lseek, open, read, write =
          posix.close, posix.lseek, posix.open, posix.read, posix.write
        SEEK_SET, SEEK_CUR, SEEK_END =
          posix.SEEK_SET, posix.SEEK_CUR, posix.SEEK_END

    - context with bad arguments:
        badargs.diagnose (lseek, "(int, int, int)")

    - it changes the current position of a file descriptor:
        _, path = posix.mkstemp (template)
        fd = open (path, posix.O_RDWR)
        expect (fd).not_to_be (nil)
        write (fd, "0123456789")
        lseek (fd, 3, SEEK_SET)
        expect (read (fd, 3)).to_be "345"
        lseek (fd, -2, SEEK_CUR)
        expect (read (fd, 3)).to_be "456"
        lseek (fd, -5, SEEK_END)
        expect (read (fd, 3)).to_be "567"
        close (fd)
        os.remove (path)



- specify file system:
  - before:
      # Make and change into a temporary subdirectory where we can
      # control all the contents for self-contained examples.
      link, mkdir, mkdtemp = posix.link, posix.mkdir, posix.mkdtemp
      dir, errmsg = mkdtemp (template)
      mkdir (dir .. "/subdir")
      link ("subdir", dir .. "/soft", true)
      touch (dir .. "/file")
      link (dir .. "/file", dir .. "/hard")
      link ("no such destination", dir .. "/dangling", true)
  - after:
      rmtmp (dir)


  - describe sync:
    - context with bad arguments:
        badargs.diagnose (posix.sync, "()")


  - describe fsync:
    - context with bad arguments:
        badargs.diagnose (posix.fsync, "(int)")

  - describe fdatasync:
    - context with bad arguments:
        if posix.fdatasync then
          badargs.diagnose (posix.fdatasync, "(int)")
        end


  - describe realpath:
    - context with bad arguments:
        badargs.diagnose (posix.realpath, "(string)")


  - describe basename:
    - before:
        basename = posix.basename

    - context with bad arguments:
        badargs.diagnose (basename, "(string)")

    - it returns a path without leading directories:
        expect (basename "/foo/bar").to_be "bar"


  - describe dirname:
    - before:
        dirname = posix.dirname

    - context with bad arguments:
        badargs.diagnose (dirname, "(string)")

    - it return a path without final element:
        expect (dirname "/foo/bar").to_be "/foo"


  - describe dir:
    - context with bad arguments:
        badargs.diagnose (posix.dir, "(?string)")


  - describe fnmatch:
    - before:
        fnmatch, FNM_PATHNAME, FNM_PERIOD =
          posix.fnmatch, posix.FNM_PATHNAME, posix.FNM_PERIOD

    - context with bad arguments:
        badargs.diagnose (fnmatch, "(string, string, ?int)")

    - it matches a file path against itself:
        expect (fnmatch ("test", "test")).to_be (true)
    - "it matches * against any filename characters":
        expect (fnmatch ("tes*", "test")).to_be (true)
        expect (fnmatch ("tes*", "test2")).to_be (true)
        expect (fnmatch ("*t*", "test")).to_be (true)
    - "it matches ? against a single filename character":
        expect (fnmatch ("tes?", "test")).to_be (true)
        expect (fnmatch ("t???", "test")).to_be (true)
        expect (fnmatch ("tes?", "tes")).to_be (false)
        expect (fnmatch ("tes?", "test2")).to_be (false)
    - "it doesn't match path separators with FNM_PATHNAME":
        expect (fnmatch ("*test", "/test")).to_be (true)
        expect (fnmatch ("*test", "/test", FNM_PATHNAME)).to_be (false)
    - "it doesn't match periods with FNM_PERIOD":
        expect (fnmatch ("*test", ".test")).to_be (true)
        expect (fnmatch ("*test", ".test", FNM_PERIOD)).to_be (false)


  - describe glob:
    - before:
        chdir, glob, mkdtemp = posix.chdir, posix.glob, posix.mkdtemp

    - context with bad arguments:
        badargs.diagnose (glob, "(?string)")

    - it matches files in the given directory:
        dir = mkdtemp (template)
        touch (dir .. "/test.1")
        touch (dir .. "/test.2")
        touch (dir .. "/extra_file")
        chdir (dir)
        globlist, errmsg = glob "test.*"
        expect (errmsg).to_be (nil)
        expect (type (globlist)).to_be "table"
        rmtmp (dir)


  - describe files:
    - before:
        files = posix.files

    - context with bad arguments:
        badargs.diagnose (files, "(?string)")

    - it returns a table of files in the given directory:
        t = {}
        for f in files (dir) do
          table.insert (t, f)
        end
        table.sort (t)
        expect (t).to_equal {".", "..", "dangling", "file", "hard", "soft", "subdir"}


  - describe getcwd:
    - context with bad arguments:
        badargs.diagnose (posix.getcwd, "()")


  - describe mkdir:
    - before:
        chdir, mkdir, rmdir = posix.chdir, posix.mkdir, posix.rmdir
        cwd = posix.getcwd ()
    - after:
        chdir (cwd)
        pcall (rmdir, "x")

    - context with bad arguments:
        badargs.diagnose (mkdir, "(string)")

    - it creates the named directory:
        expect (Emsg (mkdir "x")).not_to_contain "exists"
        expect (Emsg (chdir "x")).not_to_contain "No such flle or directory"
    - it diagnoses already existing directory:
        expect (Emsg (mkdir ".")).to_contain "exists"


  - describe chdir:
    - before:
        chdir, chmod, getcwd, mkdir, rmdir =
          posix.chdir, posix.chmod, posix.getcwd, posix.mkdir, posix.rmdir
        cwd = getcwd ()
    - after:
        chdir (cwd)
        pcall (rmdir, "x")

    - context with bad arguments:
        badargs.diagnose (chdir, "(string)")

    - it changes to a relative directory:
        thisdir = posix.basename (getcwd ())
        expect (Emsg (chdir ("../" .. thisdir))).
          not_to_contain "No such file or directory"
        expect (Emsg (chdir "..")).not_to_contain "No such file or directory"
    - it changes to an absolute directory:
        expect (Emsg (chdir "/var/tmp/")).
          not_to_contain "No such file or directory"
    - it diagnoses missing directory:
        expect (Emsg (chdir "very_unlikely_to_exist")).
          to_contain "No such file or directory"
    - it diagnoses insufficient permissions:
        mkdir "x"
        chmod ("x", "a-rwx")
        expect (Emsg (chdir "x")).
          to_contain "Permission denied"
        rmdir "x"


  - describe rmdir:
    - before:
        mkdir, rmdir = posix.mkdir, posix.rmdir

    - context with bad arguments:
        badargs.diagnose (rmdir, "(string)")

    - it removes the named directory:
        mkdir "x"
        expect (Emsg (rmdir "x")).not_to_contain "No such file or directory"
    - it diagnoses missing directory:
        expect (Emsg (rmdir ".")).to_contain "Invalid argument"


  - describe unlink:
    - context with bad arguments:
        badargs.diagnose (posix.unlink, "(string)")


  - describe link:
    - before:
        link, lstat, stat = posix.link, posix.lstat, posix.stat
        touch "xxx"
    - after:
        os.remove "xxx"

    - context with bad arguments:
        badargs.diagnose (link, "(string, string, ?boolean)")

    - it creates hard links:
        expect (Emsg (link ("xxx", "xxx-hard"))).to_be ""
        expect (lstat ("xxx-hard", "ino")).to_be (stat ("xxx", "ino"))
        os.remove "xxx-hard"
    - it creates soft links:
        expect (Emsg (link ("xxx", "xxx-soft", true))).to_be ""
        expect (lstat ("xxx-soft", "type")).to_be "link"
        os.remove "xxx-soft"

  - describe readlink:
    - before:
        readlink = posix.readlink

    - context with bad arguments:
        badargs.diagnose (readlink, "(string)")

    - it diagnoses missing file: |
        _, err, code = readlink "does not exist!"
        expect (err).to_match "^does not exist!: "
        expect (code).to_be (posix.ENOENT)
    - it diagnoses non-symbolic link: |
        _, err, code = readlink (dir .. "/file")
        expect (err).to_be (dir .. "/file: not a symbolic link")
        expect (code).to_be (posix.EINVAL)
    - it reads the contents of a symbolic link:
        expect (readlink (dir .. "/soft")).to_be "subdir"
    - it reads the contents of a dangling symbolic link:
        expect (readlink (dir .. "/dangling")).to_be "no such destination"


  - describe access:
    - before:
        access = posix.access
        touch "xxx"
    - after:
        os.remove "xxx"

    - context with bad arguments:
        badargs.diagnose (posix.access, "(string, ?string)")

    - it checks whether a file is visible to the real user:
        expect (Emsg (access ("xxx", "f"))).to_be ""
    - it checks whether a file is readable by the real user:
        expect (Emsg (access ("xxx", "r"))).to_be ""
    - it checks whether a file is writable by the real user:
        expect (Emsg (access ("xxx", "w"))).to_be ""
    - "it defaults to 'f' with no mode argument":
        expect (access ("xxx")).to_be (access ("xxx", "f"))
    - it diagnoses missing files:
        os.remove "xxx"
        expect (Emsg (access "xxx")).to_contain "No such file or directory"


  - describe fadvise:
    - context with bad arguments:
        if posix.fadvise then
          badargs.diagnose (posix.fadvise, "(file, int, int, int)")
        end


  - describe mkstemp:
    - before:
        mkstemp = posix.mkstemp
        close, isatty, open, read, stat, write =
          posix.close, posix.isatty, posix.open, posix.read, posix.stat, posix.write
        O_RDONLY = posix.O_RDONLY
        fd, path = mkstemp (template)
    - after:
        close (fd)
        os.remove (path)

    - context with bad arguments:
        badargs.diagnose (posix.mkstemp, "(string)")

    - it creates a temporary file from a template:
        expect (fd).not_to_be (nil)
        write (fd, "12345")
        expect (isatty (fd)).not_to_be (true)
        expect (stat (path, "type")).to_be "regular"
        expect (stat (path, "mode")).to_be "rw-------"
        expect (stat (path, "size")).to_be (5)
        fd2 = open (path, O_RDONLY)
        expect (read (fd2, 5)).to_be "12345"
        close (fd2)
    - it creates a new temporary file on each call:
        fd2, another = mkstemp (template)
        expect (fd2).not_to_be (fd)
        expect (another).not_to_be (path)
        close (fd2)
        os.remove (another)


  - describe mkdtemp:
    - before:
        mkdtemp, stat = posix.mkdtemp, posix.stat

    - context with bad arguments:
        badargs.diagnose (posix.mkdtemp, "(string)")

    - it creates a temporary directory from a template:
        dir, errmsg = mkdtemp (template)
        expect (dir).not_to_be (nil)
        expect (stat (dir, "type")).to_be "directory"
        expect (stat (dir, "mode")).to_be "rwx------"
        rmtmp (dir)


  - describe umask:
    - before:
        stat, umask = posix.stat, posix.umask
        saved = umask ()
        umask "rwxr-x---"
    - after:
        umask (saved)

    - context with bad arguments: |
        examples {
          ["it diagnoses argument #1 invalid mode"] = function ()
            expect (umask ("g+vv")).
              to_raise "bad argument #1 to 'umask' (bad mode)"
          end
        }

        badargs.diagnose (posix.umask, "(?string)")

    - it returns current umask:
        expect (umask ()).to_be "rwxr-x---"
    - "it sets attributes with '='":
        expect (umask "a=r").to_be "r--r--r--"
    - "it adds attributes with '+'":
        expect (umask "g+w").to_be "rwxrwx---"
    - "it removes attributes with '-'":
        expect (umask "u-r").to_be "-wxr-x---"
    - it accepts comma separated attribute specifications:
        expect (umask "a+r,g+w,u-x").to_be "rw-rwxr--"
    - it controls the mode of newly created files:
        xxx, mode = dir .. "/xxx", "rw--w-r--"
        umask (mode)
        touch (xxx)
        expect (stat (xxx, "mode")).to_be (mode)
        os.remove (xxx)


  - describe chmod:
    - before:
        chmod, stat = posix.chmod, posix.stat
        touch "xxx"
        chmod ("xxx", "rwxr-x---")
    - after:
        os.remove "xxx"

    - context with bad arguments: |
        examples {
          ["it diagnoses argument #2 invalid mode"] = function ()
            expect (chmod (".", "g+vv")).
              to_raise "bad argument #2 to 'chmod' (bad mode)"
          end
        }

        badargs.diagnose (posix.chmod, "(string, string)")

    - it sets file mode with longhand mode string:
        mode = "rw---xr--"
        expect (Emsg (chmod ("xxx", mode))).to_be ""
        expect (stat ("xxx", "mode")).to_be (mode)
    - "it sets attributes with '='":
        expect (Emsg (chmod ("xxx", "o=w"))).to_be ""
        expect (stat ("xxx", "mode")).to_be "rwxr-x-w-"
    - "it adds attributes with '+'":
        expect (Emsg (chmod ("xxx", "g+w"))).to_be ""
        expect (stat ("xxx", "mode")).to_be "rwxrwx---"
    - "it removes attributes with '-'":
        expect (Emsg (chmod ("xxx",  "u-r"))).to_be ""
        expect (stat ("xxx", "mode")).to_be "-wxr-x---"
    - it accepts comma separated attribute specifications:
        expect (Emsg (chmod ("xxx", "a+x,g+w,u-w"))).to_be ""
        expect (stat ("xxx", "mode")).to_be "r-xrwx--x"
    - it diagnoses missing files:
        os.remove "xxx"
        expect (Emsg (chmod ("xxx", "a=rwx"))).to_contain "No such file or directory"


  - describe chown:
    - context with bad arguments:
        badargs.diagnose (posix.chown, "(string, ?string|int, ?string|int)")


  - describe utime:
    - before:
        stat, utime = posix.stat, posix.utime
        touch "xxx"
    - after:
        os.remove "xxx"

    - context with bad arguments:
        badargs.diagnose (posix.utime, "(string, ?int, ?int)")

    - it sets the last file modification time:
        mtime = stat ("/etc", "mtime")
        expect (stat ("xxx", "mtime")).not_to_equal (mtime)
        expect (Emsg (utime ("xxx", mtime))).to_be ""
        expect (stat ("xxx", "mtime")).to_equal (mtime)
    - it sets the last file access time:
        atime = stat ("/etc", "atime")
        expect (stat ("xxx", "atime")).not_to_equal (atime)
        expect (Emsg (utime ("xxx", nil, atime))).to_be ""
        expect (stat ("xxx", "atime")).to_equal (atime)


  - describe stat:
    - before:
        # choose a format without seconds, that won't cause a race condition
        fmt = "%b %d %H:%M"

        getegid, geteuid, stat =
          posix.getegid, posix.geteuid, posix.stat

        badarg = function (...) return badargs.format ("stat", ...) end

    # posix.stat takes an optional string or table as its second
    # argument, followed by zero or more strings only if the second
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments:
      - 'it diagnoses missing argument #1':
          expect (stat ()).to_raise (badarg (1, "string"))
      - 'it diagnoses argument #1 type not string':
          expect (stat (false)).to_raise (badarg (1, "string", "boolean"))
      - 'it diagnoses argument #2 type not table, string or nil':
          expect (stat (".", false)).
            to_raise (badarg (2, "?table|string", "boolean"))
      - 'it diagnoses argument #2 string invalid': |
          expect (stat (".", "fubar")).
            to_raise "bad argument #2 to 'stat' (invalid option 'fubar')"
      - 'it diagnoses argument #3 type not string':
          expect (stat (".", "type", false)).
            to_raise (badarg (3, "string", "boolean"))
      - it diagnoses too many arguments:
          expect (stat (".", {}, false)).
            to_raise (badarg (3))

    - it fetches the file inode:
        expect (stat (dir .. "/hard").ino).to_be (stat (dir .. "/file").ino)
    - it fetches the file type:
        expect (stat (dir).type).to_be "directory"
        expect (stat (dir .. "/file", "type")).to_be "regular"
        expect (stat (dir .. "/soft", "type")).to_be "directory"
        expect (stat (dir .. "/hard", "type")).to_be "regular"
    - it fetches the file size:
        # skip directory size, which is system dependent
        expect (stat (dir .. "/file").size).to_be (0)
        expect (stat (dir .. "/soft", "size")).to_be (stat (dir .. "/subdir", "size"))
        expect (stat (dir .. "/hard", "size")).
          to_be (stat (dir .. "/file", "size"))
    - it fetches the file access time:
        expect (os.date (fmt, stat (dir .. "/file", "atime"))).
          to_be (os.date (fmt))
    - it fetches the file modification time:
        expect (os.date (fmt, stat (dir .. "/file", "mtime"))).
          to_be (os.date (fmt))
    - it fetches the file creation time:
        expect (os.date (fmt, stat (dir .. "/file", "ctime"))).
          to_be (os.date (fmt))
    - it fetches the file access mode:
        expect (stat (dir .. "/file").mode).to_match ("^[-rwx]+$")
        expect (stat (dir .. "/subdir", "mode")).to_match ("^[-rwx]+$")
    - it fetches the number of links:
        expect (stat (dir .. "/file").nlink).to_be (2)
        expect (stat (dir .. "/soft", "nlink")).to_be (2)
        expect (stat (dir .. "/hard", "nlink")).
          to_be (stat (dir .. "/file", "nlink"))
        expect (stat (dir .. "/subdir", "nlink")).to_be (2)
    - it fetches the owner id:
        expect (stat (dir .. "/file").uid).to_be (geteuid ())
        expect (stat (dir .. "/subdir", "uid")).to_be (geteuid ())
    - it fetches the owner group id:
        expect (stat (dir .. "/file").gid).to_be (getegid ())
        expect (stat (dir .. "/subdir", "gid")).to_be (getegid ())
    - it fetches a subtable of named fields:
        expect ({stat (dir .. "/file", "type", "size", "nlink")}).
          to_equal {"regular", 0, 2}
    - it fetches everything without an argument:
        t = stat (dir .. "/file")
        for k, v in pairs (t) do
          expect (t[k]).to_be (stat (dir .. "/file", k))
        end


  - describe lstat:
    - before:
        # choose a format without seconds, that won't cause a race condition
        fmt = "%b %d %H:%M"
        getegid, geteuid = posix.getegid, posix.geteuid
        lstat, badarg = init (posix, "lstat")

    # posix.lstat takes an optional string or table as its second
    # argument, followed by zero or more strings only if the second
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments:
      - 'it diagnoses missing argument #1':
          expect (lstat ()).to_raise (badarg (1, "string"))
      - 'it diagnoses argument #1 type not string':
          expect (lstat (false)).to_raise (badarg (1, "string", "boolean"))
      - 'it diagnoses argument #2 type not table, string or nil':
          expect (lstat (".", false)).
            to_raise (badarg (2, "?table|string", "boolean"))
      - 'it diagnoses argument #2 string invalid': |
          expect (lstat (".", "fubar")).
            to_raise "bad argument #2 to 'lstat' (invalid option 'fubar')"
      - 'it diagnoses argument #3 type not string':
          expect (lstat (".", "type", false)).
            to_raise (badarg (3, "string", "boolean"))
      - it diagnoses too many arguments:
          expect (lstat (".", {}, false)).
            to_raise (badarg (3))

    - it fetches the file inode:
        expect (lstat (dir .. "/hard").ino).to_be (lstat (dir .. "/file").ino)
    - it fetches the file type:
        expect (lstat (dir).type).to_be "directory"
        expect (lstat (dir .. "/file", "type")).to_be "regular"
        expect (lstat (dir .. "/soft", "type")).to_be "link"
        expect (lstat (dir .. "/hard", "type")).to_be "regular"
    - it fetches the file size:
        # skip directory size, which is system dependent
        expect (lstat (dir .. "/file").size).to_be (0)
        expect (lstat (dir .. "/soft", "size")).to_be (string.len ("subdir"))
        expect (lstat (dir .. "/hard", "size")).
          to_be (lstat (dir .. "/file", "size"))
    - it fetches the file access time:
        expect (os.date (fmt, lstat (dir .. "/file", "atime"))).
          to_be (os.date (fmt))
    - it fetches the file modification time:
        expect (os.date (fmt, lstat (dir .. "/file", "mtime"))).
          to_be (os.date (fmt))
    - it fetches the file creation time:
        expect (os.date (fmt, lstat (dir .. "/file", "ctime"))).
          to_be (os.date (fmt))
    - it fetches the file access mode:
        expect (lstat (dir .. "/file").mode).to_match ("^[-rwx]+$")
        expect (lstat (dir .. "/subdir", "mode")).to_match ("^[-rwx]+$")
    - it fetches the number of links:
        expect (lstat (dir .. "/file").nlink).to_be (2)
        expect (lstat (dir .. "/soft", "nlink")).to_be (1)
        expect (lstat (dir .. "/hard", "nlink")).
          to_be (lstat (dir .. "/file", "nlink"))
        expect (lstat (dir .. "/subdir", "nlink")).to_be (2)
    - it fetches the owner id:
        expect (lstat (dir .. "/file").uid).to_be (geteuid ())
        expect (lstat (dir .. "/subdir", "uid")).to_be (geteuid ())
    - it fetches the owner group id:
        expect (lstat (dir .. "/file").gid).to_be (getegid ())
        expect (lstat (dir .. "/subdir", "gid")).to_be (getegid ())
    - it fetches a subtable of named fields:
        expect ({lstat (dir .. "/file", "type", "size", "nlink")}).
          to_equal {"regular", 0, 2}
    - it fetches everything without an argument:
        t = lstat (dir .. "/file")
        for k, v in pairs (t) do
          expect (t[k]).to_be (lstat (dir .. "/file", k))
        end


  - describe statvfs:
    - before:
        statvfs, badarg = init (posix, "statvfs")

    # posix.statvfs takes an optional string or table as its second
    # argument, followed by zero or more strings only if the second
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments: |
        if statvfs then
          examples {
            ["it diagnoses missing argument #1"] = function ()
              expect (statvfs ()).to_raise (badarg (1, "string"))
            end
          }
          examples {
            ["it diagnoses argument #1 type not string"] = function ()
              expect (statvfs (false)).to_raise (badarg (1, "string", "boolean"))
            end
          }
          examples {
            ["it diagnoses argument #2 type not table, string or nil"] = function ()
              expect (statvfs (".", false)).
                to_raise (badarg (2, "?table|string", "boolean"))
            end
          }
          examples {
            ["it diagnoses argument #2 string invalid"] = function ()
              expect (statvfs (".", "fubar")).
                to_raise "bad argument #2 to 'statvfs' (invalid option 'fubar')"
            end
          }
          examples {
            ["it diagnoses argument #3 type not string"] = function ()
              expect (statvfs (".", "files", false)).
                to_raise (badarg (3, "string", "boolean"))
            end
          }
          examples {
            ["it diagnoses too many arguments"] = function ()
              expect (statvfs (".", {}, false)).
                to_raise (badarg (3))
            end
          }
        end

    - it fetches statistics for a mounted file system:
        if statvfs then
          st = statvfs "/"
          expect (type (st)).to_be "table"
          expect (st.bsize).to_be (statvfs ("/", "bsize"))
          for _, field in pairs {"bsize", "frsize", "blocks", "bfree", "bavail",
                                 "files", "ffree", "favail", "flag", "namemax"}
          do
            expect (type (st[field])).to_be "number"
            expect (st[field] >= 0).to_be (true)
          end
        end
    - it returns a non-negative value from fsid: |
        -- Merge this back into the previous example when #102 is fixed
        if statvfs then
          st = statvfs "/"
          pending "issue #102"
          expect (st[field] >= 0).to_be (true)
        end


  - describe pathconf:
    - before:
        pathconf, badarg = init (posix, "pathconf")

    # posix.pathconf takes an optional string or table as its second
    # argument, followed by zero or more strings only if the second
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments:
      - 'it diagnoses argument #1 type not string':
          expect (pathconf (false)).to_raise (badarg (1, "?string", "boolean"))
      - 'it diagnoses argument #2 type not table, string or nil':
          expect (pathconf (".", false)).
            to_raise (badarg (2, "?table|string", "boolean"))
      - 'it diagnoses argument #2 string invalid': |
          expect (pathconf (".", "fubar")).
            to_raise "bad argument #2 to 'pathconf' (invalid option 'fubar')"
      - 'it diagnoses argument #3 type not string':
          expect (pathconf (".", "NAME_MAX", false)).
            to_raise (badarg (3, "string", "boolean"))
      - it diagnoses too many arguments:
          expect (pathconf (".", {}, false)).
            to_raise (badarg (3))

    - it returns whether chown can be used on the given file:
        expect (type (pathconf ().CHOWN_RESTRICTED)).to_be "number"
        expect (pathconf (".", "CHOWN_RESTRICTED") >= 0).to_be (true)
    - it fetches the maximum number of links to the given file:
        expect (type (pathconf ().LINK_MAX)).to_be "number"
        expect (pathconf (".", "LINK_MAX") >= 0).to_be (true)
    - it fetches the maximum formatted line input length for a tty: |
        -- not passing a tty, so should return -1
        expect (type (pathconf ().MAX_CANON)).to_be "number"
        pending "issue #102"
        expect (pathconf (".", "MAX_CANON")).to_be (-1)
    - it fetches the maximum raw line input length for a tty: |
        -- not passing a tty, so should return -1
        expect (type (pathconf ().MAX_INPUT)).to_be "number"
        pending "issue #102"
        expect (pathconf (".", "MAX_INPUT")).to_be (-1)
    - it fetches the maximum filename length in this directory:
        expect (type (pathconf ().NAME_MAX)).to_be "number"
        expect (pathconf (".", "NAME_MAX") >= 0).to_be (true)
    - it fetches whether accessing overlong filenames is an error:
        expect (type (pathconf ().NO_TRUNC)).to_be "number"
        expect (pathconf (".", "NO_TRUNC") >= 0).to_be (true)
    - it fetches the maximum relative path length from this directory:
        expect (type (pathconf ().PATH_MAX)).to_be "number"
        expect (pathconf (".", "PATH_MAX") >= 0).to_be (true)
    - it fetches the size of the pipe buffer:
        expect (type (pathconf ().PIPE_BUF)).to_be "number"
        expect (pathconf (".", "PIPE_BUF") >= 0).to_be (true)
    - it fetches whether special character processing can be disabled: |
        -- not passing a tty, so should return -1
        expect (type (pathconf ().VDISABLE)).to_be "number"
        pending "issue #102"
        expect (pathconf (".", "VDISABLE")).to_be (-1)
    - it fetches a subtable of named fields:
        expect ({pathconf (".", "VDISABLE", "NAME_MAX")}).
          to_equal {pathconf (".", "VDISABLE"), pathconf (".", "NAME_MAX")}
    - it fetches everything without an argument:
        t = pathconf ()
        for k, v in pairs (t) do
          expect (t[k]).to_be (pathconf (".", k))
        end


- specify host management:
  - describe uname:
    - before:
        uname = posix.uname

    - context with bad arguments:
        badargs.diagnose (posix.uname, "(?string)")

    - it substitutes %n:
        expect (uname "%n").to_be (cmd_output "uname -n")
    - it substitutes %m:
        expect (uname "%m").to_be (cmd_output "uname -m")
    - it substitutes %r:
        expect (uname "%r").to_be (cmd_output "uname -r")
    - it outputs everything with no arguments:
        expect (uname ()).to_be (cmd_output "uname -s -n -r -v -m")


  - describe sysconf:
    - before:
        sysconf, badarg = init (posix, "sysconf")

    # posix.sysconf takes an optional string or table as its first
    # argument, followed by zero or more strings only if the first
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments:
      - 'it diagnoses argument #1 type not table, string or nil':
          expect (sysconf (false)).to_raise (badarg (1, "?table|string", "boolean"))
      - 'it diagnoses argument #1 string invalid': |
          expect (sysconf ("fubar")).
            to_raise "bad argument #1 to 'sysconf' (invalid option 'fubar')"
      - 'it diagnoses argument #2 type not string':
          expect (sysconf ("ARG_MAX", false)).
            to_raise (badarg (2, "string", "boolean"))
      - it diagnoses too many arguments:
          expect (sysconf ({}, false)).to_raise (badarg (2))

    - it fetches the maximum number of exec arguments:
        expect (type (sysconf ().ARG_MAX)).to_be "number"
        expect (sysconf ("ARG_MAX") >= 0).to_be (true)
    - it fetches the number processes per user:
        expect (type (sysconf ().CHILD_MAX)).to_be "number"
        expect (sysconf ("CHILD_MAX") >= 0).to_be (true)
    - it fetches the number of clock ticks per second:
        expect (type (sysconf ().CLK_TCK)).to_be "number"
        expect (sysconf ("CLK_TCK") >= 0).to_be (true)
    - it fetches the job control version:
        expect (type (sysconf ().JOB_CONTROL)).to_be "number"
        expect (sysconf ("JOB_CONTROL") >= 0).to_be (true)
    - it fetches the maximum number of groups:
        expect (type (sysconf ().NGROUPS_MAX)).to_be "number"
        expect (sysconf ("NGROUPS_MAX") >= 0).to_be (true)
    - it fetches the maximum number of open descriptors:
        expect (type (sysconf ().OPEN_MAX)).to_be "number"
        expect (sysconf ("OPEN_MAX") >= 0).to_be (true)
    - it fetches the number of saved ids:
        expect (type (sysconf ().SAVED_IDS)).to_be "number"
        expect (sysconf ("SAVED_IDS") >= 0).to_be (true)
    - it fetches the maximum number of open streams:
        expect (type (sysconf ().STREAM_MAX)).to_be "number"
        expect (sysconf ("STREAM_MAX") >= 0).to_be (true)
    - it fetches the maximum length of a timezone name:
        expect (type (sysconf ().TZNAME_MAX)).to_be "number"
        expect (sysconf ("TZNAME_MAX") >= 0).to_be (true)
    - "it fetches the POSIX.1 version":
        expect (type (sysconf ().VERSION)).to_be "number"
        expect (sysconf ("VERSION") >= 0).to_be (true)
    - it fetches a subtable of named fields:
        expect ({sysconf ("VERSION", "ARG_MAX", "OPEN_MAX")}).
          to_equal {sysconf "VERSION", sysconf "ARG_MAX", sysconf "OPEN_MAX"}
    - it fetches everything without an argument:
        t = sysconf ()
        for k, v in pairs (t) do
          expect (t[k]).to_be (sysconf (k))
        end



- specify message queues:
  - before:
      msgget, msgsnd, msgrcv = posix.msgget, posix.msgsnd, posix.msgrcv
      IPC_CREAT, IPC_EXCL = posix.IPC_CREAT, posix.IPC_EXCL
      EEXIST = posix.EEXIST

      mode = "rwxrwxrwx"
      mq, err, errnum = msgget (100, bor (IPC_CREAT, IPC_EXCL), mode)
      if errnum == EEXIST then
        mq, err = msgget (100, 0, mode)
      end

      type = 42
      data = "Answer to the Ultimate Question of Life"


  - describe msgget:
    - context with bad arguments:
        badargs.diagnose (posix.msgget, "(int, ?int, ?string)")

    - it creates a queue:
        expect (mq).not_to_be (err)


  - describe msgsnd:
    - context with bad arguments:
        badargs.diagnose (posix.msgsnd, "(int, int, string, ?int)")

    - it sends a message:
        ok, err = msgsnd (mq, type, data)
        expect (ok).not_to_be (err)


  - describe msgrcv:
    - context with bad arguments:
        badargs.diagnose (posix.msgrcv, "(int, int, ?int, ?int)")

    - it receives a message:
        expect ({msgrcv (mq, 128)}).to_equal {type, data, nil}


- specify process management:
  - describe nice:
    - before:
        nice = posix.nice

    - context with bad arguments:
        badargs.diagnose (nice, "(int)")

    - it adjusts the process priority:
        old = nice (1)
        expect (old).not_to_be (nil)
        new = nice (2)
        expect (new).to_be (old + 2)


  - describe raise:
    - context with bad arguments:
        badargs.diagnose (posix.raise, "(int)")


  - describe exec:
    - before:
        exec, badarg = init (posix, "exec")

    # posix.exec takes a string or non-empty table as its second
    # argument, followed by zero or more strings only if the second
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments:
      - 'it diagnoses argument #1 type not string':
          expect (exec (false)).to_raise (badarg (1, "string", "boolean"))
      - 'it diagnoses argument #2 type not table or string':
          expect (exec ("cmd", false)).
            to_raise (badarg (2, "table|string", "boolean"))
      - 'it diagnoses argument #3 type not string':
          expect (exec ("cmd", "cmd", false)).
            to_raise (badarg (3, "string", "boolean"))
      - it diagnoses too many arguments:
          expect (exec ("cmd", {}, false)).to_raise (badarg (3))


  - describe execp:
    - before:
        # redirect output to /dev/null
        dup2, fork, open, wait, O_WRONLY, O_APPEND =
          posix.dup2, posix.fork, posix.open, posix.wait, posix.O_WRONLY, posix.O_APPEND
        P_CHILD = 0

        function child (...)
          quietly = open ("/dev/null", bor (O_WRONLY, O_APPEND))
          dup2 (quietly, 1)
          execp (...)
          expect ("not reached").to_be (true)
        end

        execp, badarg = init (posix, "execp")

    # posix.execp takes a string or non-empty table as its second
    # argument, followed by zero or more strings only if the second
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments:
      - 'it diagnoses argument #1 type not string':
          expect (execp (false)).to_raise (badarg (1, "string", "boolean"))
      - 'it diagnoses argument #2 type not table or string':
          expect (execp ("cmd", false)).
            to_raise (badarg (2, "table|string", "boolean"))
      - 'it diagnoses argument #3 type not string':
          expect (execp ("cmd", "cmd", false)).
            to_raise (badarg (3, "string", "boolean"))
      - it diagnoses too many arguments:
          expect (execp ("cmd", {}, false)).to_raise (badarg (3))


    - it overwrites the running process with a shell invocation:
        process = fork ()
        if process == P_CHILD then
          child ("date", "+[%c]")
        else
          p, msg, ret = wait (process)
          expect (table.concat {msg, " ", tostring (ret)}).to_be "exited 0"
        end
    - it accepts a table of arguments:
        process = fork ()
        if process == P_CHILD then
          child ("date", {"+[%c]"})
        else
          p, msg, ret = wait (process)
          expect (table.concat {msg, " ", tostring (ret)}).to_be "exited 0"
        end
    - "it sets argv[0]":


  - describe fork:
    # NOTE: Calling expect in a child process does not report results
    #       back to parent, so we send test data over a pipe.
    - before:
        nice, execp, fork, getpid, getppid, wait =
          posix.nice, posix.execp, posix.fork, posix.getpid, posix.getppid, posix.wait
        _exit, close, pipe, read, write =
          posix._exit, posix.close, posix.pipe, posix.read, posix.write
        P_CHILD = 0

    - context with bad arguments:
        badargs.diagnose (fork, "()")

    - it copies itself to a new child process: |
        r, w = pipe ()
        process, status = fork (), 67
        if process == P_CHILD then
          close (r) -- close unused read end
          -- write parent pid and child pid to shared pipe.
          write (w, tostring (getppid ()).."\n")
          write (w, tostring (getpid "pid").."\n")
          close (w)
          _exit (status)
        else
          posix.close (w) -- close unused write end
          p, msg, ret = wait (process)
          expect (p).to_be (process)
          expect (msg).to_be "exited"
          expect (ret).to_be (status)
          -- check pids from child process.
          buf = posix.read (r, 1024)
          cppid, cpid = string.match (buf, "(%d+)\n(%d+)\n")
          close (r)
          expect (cppid).to_be (tostring (getpid "pid"))
          expect (cpid).to_be (tostring (process))
        end


  - describe _exit:
    - context with bad arguments:
        badargs.diagnose (posix. _exit, "(int)")


  - describe wait:
    - context with bad arguments:
        badargs.diagnose (posix.wait, "(?int, ?int)")


  - describe kill:
    - context with bad arguments:
        badargs.diagnose (posix.kill, "(int, ?int)")


  - describe killpg:
    - context with bad arguments:
        badargs.diagnose (posix.killpg, "(int, ?int)")


  - describe setpid:
    - before:
        setpid, badarg = init (posix, "setpid")

    - context with bad arguments:
      - 'it diagnoses missing argument #1':
          expect (setpid ()).to_raise (badarg (1, "string"))
      - 'it diagnoses argument #1 type not string':
          expect (setpid (false)).to_raise (badarg (1, "string", "boolean"))
      - 'it diagnoses argument #1 invalid option': |
          expect (setpid "fubar").
            to_raise "bad argument #1 to 'setpid' (invalid id option 'f')"
      - 'it diagnoses missing argument #2':
          expect (setpid "p").to_raise (badarg (2, "int"))
      - 'it diagnoses argument #2 type not int':
          expect (setpid ("p", false)).
            to_raise (badarg (2, "int", "boolean"))
      - 'it diagnoses missing argument #3':
          expect (setpid ("p", 0)).to_raise (badarg (3, "int"))
      - 'it diagnoses argument #3 type not int':
          expect (setpid ("p", 0, false)).
            to_raise (badarg (3, "int", "boolean"))
      - it diagnoses too many arguments:
          expect (setpid ("p", 0, 0, false)).to_raise (badarg (4))
          expect (setpid ("u", 0, false)).to_raise (badarg (3))


  - describe sleep:
    - context with bad arguments:
        badargs.diagnose (posix.sleep, "(int)")


  - describe nanosleep:
    - context with bad arguments:
        badargs.diagnose (posix.nanosleep, "(int, int)")


  - describe setenv:
    - before:
        getenv, setenv = posix.getenv, posix.setenv

    - context with bad arguments:
        badargs.diagnose (posix.setenv, "(string, ?string)")

    - it sets a new value in the process environment:
        setenv ("MYVAR", "123")
        expect (getenv "MYVAR").to_be "123"
        setenv ("MYVAR", nil)
        expect (getenv "MYVAR").to_be (nil)


  - describe getenv:
    - before:
        getenv = posix.getenv

    - context with bad arguments:
        badargs.diagnose (posix.getenv, "(?string)")

    - it fetches a table of process environment variables: |
        volatile = { _=true, CWD=true, LUA_PATH=true, PWD=true, SHLVL=true, }
        for k,v in pairs (getenv ()) do
         if not volatile[k] then
           expect (hell.spawn ('echo "' .. k .. '=$' .. k .. '"')).
             to_contain_output (k.."="..v)
         end
        end
    - it fetches a named process environment variable:
        expect (getenv "USER").to_be (cmd_output ('echo "$USER"'))
        expect (getenv "HOME").to_be (cmd_output ('echo "$HOME"'))
        expect (getenv "SHELL").to_be (cmd_output ('echo "$SHELL"'))
    - it returns nil for an absent environment setting:
        expect (getenv "very_unlikely_to_be_set").to_be (nil)


  - describe times:
    - before:
        table.unpack = table.unpack or unpack
        times, badarg = init (posix, "times")

    # posix.times takes an optional string or table as its first
    # argument, followed by zero or more strings only if the first
    # argument was a string; since we can't express that with
    # `badargs.diagnose` do it all manually again...
    - context with bad arguments:
      - 'it diagnoses argument #1 type not table, string or nil':
          expect (times (false)).to_raise (badarg (1, "?table|string", "boolean"))
      - 'it diagnoses argument #1 string invalid': |
          expect (times ("fubar")).
            to_raise "bad argument #1 to 'times' (invalid option 'fubar')"
      - 'it diagnoses argument #2 type not string':
          expect (times ("utime", false)).
            to_raise (badarg (2, "string", "boolean"))
      - it diagnoses too many arguments:
          expect (times ({}, false)).to_raise (badarg (2))

    - it fetches the user time:
        expect (type (times ().utime)).to_be "number"
        expect (times ("utime") >= 0).to_be (true)
    - it fetches the system time:
        expect (type (times ().stime)).to_be "number"
        expect (times ("stime") >= 0).to_be (true)
    - it fetches the children user time:
        expect (type (times ().cutime)).to_be "number"
        expect (times ("cutime") >= 0).to_be (true)
    - it fetches the children system time:
        expect (type (times ().cstime)).to_be "number"
        expect (times ("cstime") >= 0).to_be (true)
    - it fetches the elapsed time:
        expect (type (times ().elapsed)).to_be "number"
        expect (times ("elapsed") >= 0).to_be (true)
    - it fetches a subtable of named fields: |
        keys = {"utime", "cutime"}
        t = {times (table.unpack (keys))}
        pending "API inconsistency, issue #107"
        expect (t).to_contain.all_of (keys)
        for _, v in ipairs (keys) do
          expect (type (t[v])).to_be "number"
        end
    - it fetches everything without an argument:
        keys = {"utime", "stime", "cutime", "cstime", "elapsed"}
        t = times ()
        expect (t).to_contain.all_of (keys)
        for _, v in ipairs (keys) do
          expect (type (t[v])).to_be "number"
        end


  - describe setrlimit:
    - before:
        setrlimit, badarg = init (posix, "setrlimit")

    - context with bad arguments: |
        examples {
          ["it diagnoses argument #1 invalid option"] = function ()
            expect (setrlimit ("fubar")).
              to_raise "bad argument #1 to 'setrlimit' (invalid option 'fubar')"
          end
        }

        badargs.diagnose (setrlimit, "(string, ?int, ?int)")


  - describe getrlimit:
    - before:
        getrlimit, badarg = init (posix, "getrlimit")

    - context with bad arguments: |
        examples {
          ["it diagnoses argument #1 invalid option"] = function ()
            expect (getrlimit ("fubar")).
              to_raise "bad argument #1 to 'getrlimit' (invalid option 'fubar')"
          end
        }

        badargs.diagnose (getrlimit, "(string)")


  - describe sched_setscheduler:
    - context with bad arguments:
        if posix.sched_setscheduler then
          badargs.diagnose (posix.sched_setscheduler, "(?int, ?int, ?int)")
        end


  - describe sched_getscheduler:
    - context with bad arguments:
        if posix.sched_getscheduler then
          badargs.diagnose (posix.sched_getscheduler, "(?int)")
        end



- specify signal handling:
  - describe signal:
    - context with bad arguments:
        badargs.diagnose (posix.signal, "(int, ?function|string, ?int)")



- specify socket management:
  - before:
      bind, setsockopt, socket = posix.bind, posix.setsockopt, posix.socket
      recvfrom, sendto = posix.recvfrom, posix.sendto
      AF_INET, AF_INET6, AF_UNIX, AF_NETLINK =
        posix.AF_INET, posix.AF_INET6, posix.AF_UNIX, posix.AF_NETLINK
      IPPROTO_TCP, SOCK_DGRAM = posix.IPPROTO_TCP, posix.SOCK_DGRAM
      SOL_SOCKET, SO_RCVTIMEO = posix.SOL_SOCKET, posix.SO_RCVTIMEO

  - describe socket:
    - context with bad arguments:
        badargs.diagnose (posix.socket, "(int, int, int)")


  - describe socketpair:
    - context with bad arguments:
        badargs.diagnose (posix.socketpair, "(int, int, int)")


  - describe getaddrinfo:
    - before:
        getaddrinfo, badarg = init (posix, "getaddrinfo")

    - context with bad arguments: |
        badargs.diagnose (getaddrinfo, "(?string, ?string|int, ?table)")

        examples {
          ["it diagnoses unspecified host and service"] = function ()
            expect (getaddrinfo ()).
              to_raise "bad argument #2 to 'getaddrinfo' (string or int expected, got no value)"
          end
        }
        examples {
          ["it diagnoses invalid hints fields"] = function ()
            expect (getaddrinfo ("localhost", nil, {
              protacol=IPPROTO_TCP
            })).to_raise "bad argument #3 to 'getaddrinfo' (invalid field name 'protacol')"
            expect (getaddrinfo ("localhost", nil, {
              family=AF_INET, sacktype=SOCK_DGRAM, protocol=IPPROTO_TCP,
            })).to_raise "bad argument #3 to 'getaddrinfo' (invalid field name 'sacktype')"
          end
        }
        examples {
          ["it diagnoses wrong hints field types"] = function ()
            expect (getaddrinfo ("localhost", nil, {
              family=false,
            })).to_raise (badarg (3, "int", "family", "boolean"))
            expect (getaddrinfo ("localhost", nil, {
              family=AF_INET, socktype=false,
            })).to_raise (badarg (3, "int", "socktype", "boolean"))
            expect (getaddrinfo ("localhost", nil, {
              family=AF_INET, socktype=SOCK_DGRAM, protocol=false,
            })).to_raise (badarg (3, "int", "protocol", "boolean"))
            expect (getaddrinfo ("localhost", nil, {
              family=AF_INET, socktype=SOCK_DGRAM, protocol=IPPROTO_TCP, flags=false,
            })).to_raise (badarg (3, "int", "flags", "boolean"))
          end
        }


  - describe connect:
    - before:
        connect, badarg = init (posix, "connect")

    - context with bad arguments: |
        badargs.diagnose (connect, "(int, table)")

        examples {
          ["it diagnoses wrong family types"] = function ()
            expect (connect (42, {family=false})).
              to_raise (badarg (2, "int", "family", "boolean"))
            expect (connect (42, {family=-1})).
              to_raise "bad argument #2 to 'connect' (unsupported family type -1)"
          end
        }
        examples {
          ["it diagnoses wrong AF_INET field types"] = function ()
            expect (connect (42, {family=AF_INET, port=false})).
              to_raise (badarg (2, "int", "port", "boolean"))
            expect (connect (42, {family=AF_INET, port=9999, addr=false})).
              to_raise (badarg (2, "string", "addr", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_INET fields"] = function ()
            expect (connect (42, {
              family=AF_INET, port=9999, addr="127.0.0.1", flags=false
            })).to_raise "bad argument #2 to 'connect' (invalid field name 'flags')"
          end
        }
        examples {
          ["it diagnoses wrong AF_INET6 field types"] = function ()
            expect (connect (42, {family = AF_INET6, port = false})).
              to_raise (badarg (2, "int", "port", "boolean"))
            expect (connect (42, {family = AF_INET6, port = 9999, addr = false})).
              to_raise (badarg (2, "string", "addr", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_INET6 fields"] = function ()
            expect (connect (42, {
              family=AF_INET6, port=9999, addr="::", flags=false
            })).to_raise "bad argument #2 to 'connect' (invalid field name 'flags')"
          end
        }
        examples {
          ["it diagnoses wrong AF_UNIX field types"] = function ()
            expect (connect (42, {family = AF_UNIX, path = false})).
              to_raise (badarg (2, "string", "path", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_UNIX fields"] = function ()
            expect (connect (42, {family=AF_UNIX, path="/tmp/afunix", port=9999})).
              to_raise "bad argument #2 to 'connect' (invalid field name 'port')"
          end
        }
        if AF_NETLINK then
          examples {
            ["it diagnoses wrong AF_NETLINK field types"] = function ()
                expect (connect (42, {family = AF_NETLINK, pid = false})).
                  to_raise (badarg (2, "int", "pid", "boolean"))
                expect (connect (42, {family = AF_NETLINK, pid = 9999, groups = false})).
                  to_raise (badarg (2, "int", "groups", "boolean"))
            end
          }
          examples {
            ["it diagnoses invalid AF_NETLINK fields"] = function ()
              expect (connect (42, {family=AF_NETLINK, pid=9999, groups=9999, port=9999})).
                to_raise "bad argument #2 to 'connect' (invalid field name 'port')"
            end
          }
        end


  - describe bind:
    - before:
        bind, badarg = init (posix, "bind")

    - context with bad arguments: |
        badargs.diagnose (bind, "(int, table)")

        examples {
          ["it diagnoses wrong family types"] = function ()
            expect (bind (42, {family=false})).
              to_raise (badarg (2, "int", "family", "boolean"))
            expect (bind (42, {family=-1})).
              to_raise "bad argument #2 to 'bind' (unsupported family type -1)"
          end
        }
        examples {
          ["it diagnoses wrong AF_INET field types"] = function ()
            expect (bind (42, {family=AF_INET, port=false})).
              to_raise (badarg (2, "int", "port", "boolean"))
            expect (bind (42, {family=AF_INET, port=9999, addr=false})).
              to_raise (badarg (2, "string", "addr", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_INET fields"] = function ()
            expect (bind (42, {
              family=AF_INET, port=9999, addr="127.0.0.1", flags=false
            })).to_raise "bad argument #2 to 'bind' (invalid field name 'flags')"
          end
        }
        examples {
          ["it diagnoses wrong AF_INET6 field types"] = function ()
            expect (bind (42, {family = AF_INET6, port = false})).
              to_raise (badarg (2, "int", "port", "boolean"))
            expect (bind (42, {family = AF_INET6, port = 9999, addr = false})).
              to_raise (badarg (2, "string", "addr", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_INET6 fields"] = function ()
            expect (bind (42, {
              family=AF_INET6, port=9999, addr="::", flags=false
            })).to_raise "bad argument #2 to 'bind' (invalid field name 'flags')"
          end
        }
        examples {
          ["it diagnoses wrong AF_UNIX field types"] = function ()
            expect (bind (42, {family = AF_UNIX, path = false})).
              to_raise (badarg (2, "string", "path", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_UNIX fields"] = function ()
            expect (bind (42, {family=AF_UNIX, path="/tmp/afunix", port=9999})).
              to_raise "bad argument #2 to 'bind' (invalid field name 'port')"
          end
        }
        if AF_NETLINK then
          examples {
            ["it diagnoses wrong AF_NETLINK field types"] = function ()
                expect (bind (42, {family = AF_NETLINK, pid = false})).
                  to_raise (badarg (2, "int", "pid", "boolean"))
                expect (bind (42, {family = AF_NETLINK, pid = 9999, groups = false})).
                  to_raise (badarg (2, "int", "groups", "boolean"))
            end
          }
          examples {
            ["it diagnoses invalid AF_NETLINK fields"] = function ()
              expect (bind (42, {family=AF_NETLINK, pid=9999, groups=9999, port=9999})).
                to_raise "bad argument #2 to 'bind' (invalid field name 'port')"
            end
          }
        end


  - describe listen:
    - context with bad arguments:
        badargs.diagnose (posix.listen, "(int, int)")


  - describe accept:
    - context with bad arguments:
        badargs.diagnose (posix.accept, "(int)")


  - describe recv:
    - context with bad arguments:
        badargs.diagnose (posix.recv, "(int, int)")


  - describe recvfrom:
    - context with bad arguments:
        badargs.diagnose (posix.recvfrom, "(int, int)")


  - describe send:
    - context with bad arguments:
        badargs.diagnose (posix.send, "(int, string)")


  - describe sendto:
    - before:
        sendto, badarg = init (posix, "sendto")

    - context with bad arguments: |
        badargs.diagnose (sendto, "(int, string, table)")

        examples {
          ["it diagnoses wrong family types"] = function ()
            expect (sendto (42, "msg", {family=false})).
              to_raise (badarg (3, "int", "family", "boolean"))
            expect (sendto (42, "msg", {family=-1})).
              to_raise "bad argument #3 to 'sendto' (unsupported family type -1)"
          end
        }
        examples {
          ["it diagnoses wrong AF_INET field types"] = function ()
            expect (sendto (42, "msg", {family=AF_INET, port=false})).
              to_raise (badarg (3, "int", "port", "boolean"))
            expect (sendto (42, "msg", {family=AF_INET, port=9999, addr=false})).
              to_raise (badarg (3, "string", "addr", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_INET fields"] = function ()
            expect (sendto (42, "msg", {
              family=AF_INET, port=9999, addr="127.0.0.1", flags=false
            })).to_raise "bad argument #3 to 'sendto' (invalid field name 'flags')"
          end
        }
        examples {
          ["it diagnoses wrong AF_INET6 field types"] = function ()
            expect (sendto (42, "msg", {family = AF_INET6, port = false})).
              to_raise (badarg (3, "int", "port", "boolean"))
            expect (sendto (42, "msg", {family = AF_INET6, port = 9999, addr = false})).
              to_raise (badarg (3, "string", "addr", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_INET6 fields"] = function ()
            expect (sendto (42, "msg", {
              family=AF_INET6, port=9999, addr="::", flags=false
            })).to_raise "bad argument #3 to 'sendto' (invalid field name 'flags')"
          end
        }
        examples {
          ["it diagnoses wrong AF_UNIX field types"] = function ()
            expect (sendto (42, "msg", {family = AF_UNIX, path = false})).
              to_raise (badarg (3, "string", "path", "boolean"))
          end
        }
        examples {
          ["it diagnoses invalid AF_UNIX fields"] = function ()
            expect (sendto (42, "msg", {family=AF_UNIX, path="/tmp/afunix", port=9999})).
              to_raise "bad argument #3 to 'sendto' (invalid field name 'port')"
          end
        }
        if AF_NETLINK then
          examples {
            ["it diagnoses wrong AF_NETLINK field types"] = function ()
                expect (sendto (42, "msg", {family = AF_NETLINK, pid = false})).
                  to_raise (badarg (3, "int", "pid", "boolean"))
                expect (sendto (42, "msg", {family = AF_NETLINK, pid = 9999, groups = false})).
                  to_raise (badarg (3, "int", "groups", "boolean"))
            end
          }
          examples {
            ["it diagnoses invalid AF_NETLINK fields"] = function ()
              expect (sendto (42, "msg", {family=AF_NETLINK, pid=9999, groups=9999, port=9999})).
                to_raise "bad argument #3 to 'sendto' (invalid field name 'port')"
            end
          }
        end


  - describe shutdown:
    - context with bad arguments:
        badargs.diagnose (posix.shutdown, "(int, int)")


  - describe setsockopt:
    - before:
        SOL_SOCKET, SO_LINGER, IPPROTO_TCP =
          posix.SOL_SOCKET, posix.SO_LINGER, posix.IPPROTO_TCP

        setsockopt, badarg = init (posix, "setsockopt")

    - context with bad arguments:
      - 'it diagnoses missing argument #1':
          expect (setsockopt ()).to_raise (badarg (1, "int"))
      - 'it diagnoses argument #1 type not int':
          expect (setsockopt (false)).to_raise (badarg (1, "int", "boolean"))
      - 'it diagnoses missing argument #2':
          expect (setsockopt (1)).to_raise (badarg (2, "int"))
      - 'it diagnoses argument #2 type not int':
          expect (setsockopt (1, false)).to_raise (badarg (2, "int", "boolean"))
      - 'it diagnoses missing argument #3':
          expect (setsockopt (1, 2)).to_raise (badarg (3, "int"))
      - 'it diagnoses argument #3 type not int':
          expect (setsockopt (1, 2, false)).to_raise (badarg (3, "int", "boolean"))
      - 'it diagnoses missing argument #4':
          expect (setsockopt (1, SOL_SOCKET, SO_LINGER)).
            to_raise (badarg (4, "int"))
      - 'it diagnoses argument #4 type not int':
          expect (setsockopt (1, SOL_SOCKET, SO_LINGER, false)).
            to_raise (badarg (4, "int", "boolean"))
      - 'it diagnoses missing argument #5':
          expect (setsockopt (1, SOL_SOCKET, SO_LINGER, 4)).
            to_raise (badarg (5, "int"))
      - 'it diagnoses argument #5 type not int':
          expect (setsockopt (1, SOL_SOCKET, SO_LINGER, 4, false)).
            to_raise (badarg (5, "int", "boolean"))
      - it diagnoses too many arguments:
          expect (setsockopt (1, SOL_SOCKET, IPPROTO_TCP, 4, false)).
            to_raise (badarg (5))
          expect (setsockopt (1, SOL_SOCKET, SO_LINGER, 4, 5, false)).
            to_raise (badarg (6))

    - it communicates with IPV4 and IPV6 over loopback: |
        fd = socket (AF_INET6, SOCK_DGRAM, 0)
        expect (type (fd)).to_be "number"
        expect (fd >= 0).to_be (true)

        expect (setsockopt (fd, SOL_SOCKET, SO_RCVTIMEO, 1, 0)).to_be (0)

        pending "returning `true` is NOT a minimal binding!"
        expect (bind (fd, { family = AF_INET6, addr = "::", port = 9999 })).
          to_be (0)

        pending "issue #92"
        sockt = { family = AF_INET, addr = "127.0.0.1", port = 59999 }
        expect (sendto (fd, "Test ipv4", sockt)).to_be (9)

        data, so = recvfrom (fd, 1024)
        expect (data).to_be "Test ipv4"



- specify system log:
  - describe openlog:
    - before:
        openlog = posix.openlog

    - context with bad arguments: |
        if openlog then
          badargs.diagnose (openlog, "(string, ?string, ?int)")

          examples {
            ["it diagnoses invalid options"] = function ()
              expect (openlog ("log", "cp*")).
                to_raise "bad argument #2 to 'openlog' (invalid openlog option '*')"
            end
          }
        end


  - describe syslog:
    - context with bad arguments:
        if posix.syslog then
          badargs.diagnose (posix.syslog, "(int, string)")
        end


  - describe closelog:
    - context with bad arguments:
        if posix.closelog then
          badargs.diagnose (posix.closelog, "()")
        end


  - describe setlogmask:
    - context with bad arguments:
        if posix.setlogmask then
          badargs.diagnose (posix.setlogmask, "(?int*)")
        end



- specify terminal handling:
  - describe openpt:
    - before:
        grantpt, openpt, ptsname, stat, unlockpt =
          posix.grantpt, posix.openpt, posix.ptsname, posix.stat, posix.unlockpt
        open, close = posix.open, posix.close
        O_RDWR, O_NOCTTY = posix.O_RDWR, posix.O_NOCTTY

    - context with bad arguments:
        badargs.diagnose (posix.openpt, "(int)")

    - it can create a pseudoterminal:
        masterfd = openpt (bor (O_RDWR, O_NOCTTY))
        expect (type (masterfd)).to_be "number"
        expect (masterfd > 0).to_be (true)
        expect (Emsg (grantpt (masterfd))).to_be ""
        expect (Emsg (unlockpt (masterfd))).to_be ""
        slavename = ptsname (masterfd)
        expect (stat (slavename, "type")).to_be "character device"
        slavefd = open (slavename, bor (O_RDWR, O_NOCTTY))
        expect (type (slavefd)).to_be "number"
        expect (slavefd > 0).to_be (true)
        close (slavefd)
        close (masterfd)


  - describe grantpt:
    - context with bad arguments:
        badargs.diagnose (posix.grantpt, "(int)")


  - describe unlockpt:
    - context with bad arguments:
        badargs.diagnose (posix.unlockpt, "(int)")


  - describe ptsname:
    - context with bad arguments:
        badargs.diagnose (posix.ptsname, "(int)")


  - describe ttyname:
    - before:
        ttyname = posix.ttyname

    - context with bad arguments:
        badargs.diagnose (posix.ttyname, "(?int)")

    - it takes a file descriptor argument:
        expect (ttyname (2)).to_contain.any_of {"console", "pts", "tty"}
    - it returns a string:
        expect (type (ttyname (1))).to_be "string"
    - it defaults the first argument to 0:
        expect (ttyname ()).to_be (ttyname (0))


  - describe ctermid:
    - before:
        ctermid = posix.ctermid

    - context with bad arguments:
        badargs.diagnose (posix.ctermid, "()")

    - it returns the pathname of the controlling terminal:
        expect (ctermid ()).to_match.any_of {"/.*pts.*", "/.*tty.*"}


  - describe isatty:
    - context with bad arguments:
        badargs.diagnose (posix.isatty, "(int)")


  - describe tcsetattr:
    - context with bad arguments:
        badargs.diagnose (posix.tcsetattr, "(int, int, table)")


  - describe tcgetattr:
    - context with bad arguments:
        badargs.diagnose (posix.tcgetattr, "(int)")


  - describe tcsendbreak:
    - context with bad arguments:
        badargs.diagnose (posix.tcsendbreak, "(int, int)")


  - describe tcdrain:
    - context with bad arguments:
        badargs.diagnose (posix.tcdrain, "(int)")


  - describe tcflush:
    - context with bad arguments:
        badargs.diagnose (posix.tcflush, "(int, int)")


  - describe tcflow:
    - context with bad arguments:
        badargs.diagnose (posix.tcflow, "(int, int)")



- specify time and date:
  - describe gettimeofday:
    - before:
        gettimeofday = posix.gettimeofday

    - context with bad arguments:
        badargs.diagnose (posix.gettimeofday, "()")

    - it fetches the current epoch time:
        t = gettimeofday ()
        expect (t.sec).to_be (posix.time ())
        expect (type (t.usec)).to_be "number"
        expect (t.usec >= 0).to_be (true)


  - describe time:
    - context with bad arguments:
        badargs.diagnose (posix.time, "()")


  - describe localtime:
    - context with bad arguments:
        badargs.diagnose (posix.localtime, "(?int)")


  - describe gmtime:
    - context with bad arguments:
        badargs.diagnose (posix.gmtime, "(?int)")


  - describe clock_getres:
    - context with bad arguments:
        if posix.clock_getres then
          badargs.diagnose (posix.clock_getres, "(string)")
        end


  - describe clock_gettime:
    - context with bad arguments:
        if posix.clock_gettime then
          badargs.diagnose (posix.clock_gettime, "(string)")
        end


  - describe strftime:
    - context with bad arguments:
        badargs.diagnose (posix.strftime, "(string)")


  - describe strptime:
    - context with bad arguments:
        badargs.diagnose (posix.strptime, "(string, string)")


  - describe mktime:
    - context with bad arguments:
        badargs.diagnose (posix.mktime, "(table)")



- specify user management:
  - describe getlogin:
    - context with bad arguments:
        badargs.diagnose (posix.getlogin, "()")


  - describe getgroups:
    - context with bad arguments:
        if posix.getgroups then
          badargs.diagnose (posix.getgroups, "()")
        end


  - describe crypt:
    - before:
        crypt = posix.crypt
        key, salt = "hello", "pl"

    - context with bad arguments:
        if posix.crypt then
          badargs.diagnose (posix.crypt, "(string, string)")
        end

    - it can perform repeatable one-way hashing:
        hash = crypt (key, salt)
        expect (crypt (key, salt)).to_be (hash)
    - it encrypts differently for a different salt:
        expect (crypt (key, salt)).not_to_equal (crypt (key, "/."))
