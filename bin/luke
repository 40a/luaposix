#!/usr/bin/env lua

--[[
  TODO:
  - don't manipulate external DEFAULTENV state from searchlibs calls
  - add a --debug mode for tracing configs i/o
  - support copy_directories
  - support adhoc targets
  - consolidate searchlibs with external_libraries
]]

local _ENV = {
  LUAVERSION	= _VERSION:gsub('[^0-9%.]+', ''),
  append	= table.insert,
  arg		= arg,
  assert        = assert,
  ceil		= math.ceil,
  close		= io.close,
  concat	= table.concat,
  destructure	= next,
  error		= error,
  exit		= os.exit,
  float		= tonumber,
  format	= string.format,
  getenv	= os.getenv,
  getmetatable	= getmetatable,
  gsub		= string.gsub,
  isempty	= function(x) return type(x) == 'table' and not next(x) end,
  isfile	= function(x) return io.type(x) == 'file' end,
  isfunction	= function(x) return type(x) == 'function' end,
  isnil		= function(x) return x == nil end,
  isstring	= function(x) return type(x) == 'string' end,
  istable	= function(x) return type(x) == 'table' end,
  load		= load,
  loadstring	= loadstring,
  match		= string.match,
  next		= next,
  nop		= function () end,
  open		= io.open,
  pack		= table.pack or function(...) return {n=select('#', ...), ...} end,
  pcall		= pcall,
  popen		= io.popen,
  print		= print,
  remove	= table.remove,
  rm		= os.remove,
  select	= select,
  setfenv	= setfenv,
  setmetatable	= setmetatable,
  sort		= table.sort,
  stderr	= io.stderr,
  stdout	= io.stdout,
  str		= tostring,
  tmpname	= os.tmpname,
  tointeger	= math.tointeger,
  table_unpack	= table.unpack or unpack,
  type		= type,
  upper		= string.upper,
}
(setfenv or nop)(1, _ENV)


local function copy(iterable)
  local r = {}
  for k, v in next, iterable do
    r[k] = v
  end
  return r
end


local int = tointeger or function(x)
  local i = float(x)
  if i and ceil(i) - i == 0.0 then
    return i
  end
end


local function iscallable(x)
  return isfunction(x) and x or (getmetatable(x) or {}).__call
end


local function getmetamethod(x, n)
  return iscallable((getmetatable (x) or {})[str(n)])
end


local function rawlen(x)
  if not istable(x) then
    return #x
  end

  local n = #x
  for i = 1, n do
    if x[i] == nil then
      return i - 1
    end
  end
  return n
end


local function len(x)
  local m = getmetamethod(x, '__len')
  return m and m(x) or rawlen(x)
end


if setfenv ~= nil then

  local _loadstring = loadstring
  loadstring = function(str, filename, env)
    chunk, err = _loadstring(str, filename)
    if chunk ~= nil and env ~= nil then
      setfenv(chunk, env)
    end
    return chunk, err
  end

else

  loadstring = function(str, filename, env)
    return load(str, filename, "t", env)
  end

end


local function maxn(iterable)
  local n = 0
  for k, v in next, iterable do
    local i = int(k)
    if i and i > n then
      n = i
    end
  end
  return n
end


local function merge(r, iterable)
  for k, v in next, iterable do
    r[k] = r[k] or v
  end
  return r
end


local function unpack(seq, i, j)
  return table_unpack(seq, int(i) or 1, int(j) or int(seq.n) or len(seq))
end



--[[ ====================== ]]--
--[[ Language enhancements. ]]--
--[[ ====================== ]]--


local function any(seq)
  for i = 1, int(seq.n) or len(seq) do
    if seq[i] then
      return true
    end
  end
  return false
end


local function apply(fn, argu)
  assert(fn ~= nil, 'cannot apply nil-valued function')
  if iscallable(fn) then
    return fn(unpack(argu))
  end
  return fn
end


local function bind(fn, bound)
  local n = bound.n or maxn(bound)

  return function (...)
    local argu, unbound = copy(bound), pack(...)

    local i = 1
    for j = 1, unbound.n do
      while argu[i] ~= nil do
        i = i + 1
      end
      argu[i], i = unbound[j], i + 1
    end
    bound.n = n >= i and n or i - 1

    return apply(fn, argu)
  end
end


local function call(fn, ...)
  assert(fn ~= nil, 'cannot call nil-valued function')
  if iscallable(fn) then
    return fn(...)
  end
  return fn
end


local function case(s, branches)
  if branches[s] ~= nil then
    return call(branches[s], s)
  end
  local DEFAULT = 1
  for pattern, fn in next, branches do
    if pattern ~= DEFAULT then
      local argu = pack(match(s, '^' .. pattern .. '$'))
      if argu[1] ~= nil then
        return apply(fn, argu)
      end
    end
  end
  return call(branches[DEFAULT], s)
end


local function collect(keylist, dict)
  local r = {}
  for i = 1, int(keylist.n) or len(keylist) do
    local k = keylist[i]
    r[k] = dict[k]
  end
  return r
end


local function cond(...)
  local clauses = pack(...)
  for i = 1, clauses.n do
    local expr, branch = destructure(clauses[i])
    if expr then
      return call(branch, expr)
    end
  end
end


local function contains(seq, v)
  for i = 1, int(seq.n) or len(seq) do
    if seq[i] == v then
      return true
    end
  end
end


local function each(seq)
  local i, n = 0, int(seq.n) or len(seq)
  return function()
    if i < n then
      i = i + 1
      return seq[i]
    end
  end
end


local function fatal(...)
  local msg = (...)
  if select("#", ...) > 1 then
    msg = format(...)
  end
  stderr:write('luke: fatal: ' .. msg .. '\n')
  exit(1)
end


local function filter(seq, block)
  block = block or function(x) return x ~= nil end
  local r = {}
  for i = 1, int(seq.n) or len(seq) do
    local v = seq[i]
    if block(v) then
      append(r, v)
    end
  end
  return r
end


local function hoist(keylist, dict)
  local r = {}
  for i = 1, int(keylist.n) or len(keylist) do
    merge(r, dict[keylist[i]])
  end
  return not isempty(r) and r or nil
end


local function keys(iterable)
  local r = {}
  for k in next, iterable do
    append(r, k)
  end
  return r
end


local function map(seq, block)
  local r = {}
  if isnil(seq) then
    return r
  end
  for i = 1, int(seq.n) or len(seq) do
    r[i] = block(seq[i])
  end
  return r
end


local function mapvalues(dict, block)
  local r = {}
  for k, v in next, dict do
    r[k] = block(v)
  end
  return r
end


local function partition(seq, block)
  local r, s = {}, {}
  for i = 1, int(seq.n) or len(seq) do
    local v = seq[i]
    if block(v) then
      append(r, v)
    else
      append(s, v)
    end
  end
  return r, s
end


local function pop(seq)
  if int(seq.n) then
    seq.n = seq.n - 1
  end
  return remove(seq)
end


local function reduce(seq, acc, block)
  if block == nil then
    acc, block = {}, acc
  end
  for i = 1, len(seq) do
    acc = block(acc, seq[i]) or acc
  end
  return acc
end


local function set(seq)
  local r = {}
  for i = 1, len(seq) do
    r[seq[i]] = true
  end
  return r
end


local function with(...)
  local argu = pack(...)
  local block = pop(argu)
  local r = pack(apply(block, argu))
  for cm in each(argu) do
    cm:release()
  end
  return unpack(r)
end


local function slurp(cm)
  return with(cm, function(h)
    return h:read '*a'
  end)
end


local function values(iterable)
  local r = {}
  for _, v in next, iterable do
    append(r, v)
  end
  return r
end



--[[ =========== ]]--
--[[ Prototypes. ]]--
--[[ =========== ]]--


local ContextManager
do
  local contextmanager_mt = {
    -- Return a closure that forwards arguments to the named method
    -- on the context object with the correct `self` argument value.
    __index = function(self, key)
      if iscallable(self.context[key]) then
        return function(_, ...)
          return self.context[key](self.context, ...)
        end
      end
    end,
  }

  ContextManager = function(release, acquire, ...)
    local cm = {
      context = acquire(...),
      release = release,
      n       = select("#", ...), ...
    }
    if cm.context ~= nil then
      setmetatable(cm, contextmanager_mt)
    end
    return cm
  end
end


local File, TmpFile, Pipe
do
  local function context_close(cm)
    return isfile(cm.context) and close(cm.context)
  end


  File = function(fname, mode)
    return ContextManager(context_close, open, fname, mode)
  end


  TmpFile = function(fname, mode)
    return ContextManager(function(cm)
      if context_close(cm) then
        return rm(cm[1])
      end
      return false
    end, open, fname, mode)
  end


  Pipe = function(cmd, mode)
    return ContextManager(context_close, popen, cmd, mode)
  end
end


local function OrderedDict(...)
  local r, argu = {}, pack(...)
  for i = 1, argu.n do
    local k, v = destructure(argu[i])
    append(r, k)
    r[k] = v
  end
  return r
end



--[[ ============= ]]--
--[[ Environments. ]]--
--[[ ============= ]]--


local filter_platforms
do
  local canon = {
    ['AIX']       = {'unix', 'aix'},
    ['FreeBSD']   = {'unix', 'freebsd', 'bsd'},
    ['OpenBSD']   = {'unix', 'openbsd', 'bsd'},
    ['NetBSD']    = {'unix', 'netbsd', 'bsd'},
    ['Darwin']    = {'unix', 'macosx', 'bsd'},
    ['Linux']     = {'unix', 'linux'},
    ['SunOS']     = {'unix', 'solaris'},
    ['CYGWIN.*']  = {'unix', 'cygwin'},
    ['Windows.*'] = {'windows', 'win32'},
    ['MINGW.*']   = {'windows', 'mingw32', 'win32'},
    ['procnto.*'] = {'qnx'},
    ['QNX']       = {'qnx'},
  }


  local allplatforms = set(reduce(values(canon), {}, function(acc, platforms)
    map(platforms, bind(append, {acc}))
  end))


  local platforms = canon[popen('uname -s'):read'*l'] or {'unix'}


  local function isplatform(x)
    return allplatforms[x] ~= nil
  end

  filter_platforms = function(t)
    local r = {}
    for k, v in next, t do
      if k == 'platforms' then
        local branches, defaults = partition(keys(v), isplatform)
        local matches = filter(branches, bind(contains, {platforms}))
        merge(r, hoist(matches, v) or collect(defaults, v))
      elseif istable(v) then
        r[k] = filter_platforms(v)
      else
        r[k] = r[k] or v
      end
    end
    return r
  end
end


local function pushenv(new, env)
  return setmetatable(new, {__index=env})
end


local function SHELLENV(_, v)
  return getenv(v)
end


local DEFAULTENV = pushenv(filter_platforms {
  LUAVERSION    = LUAVERSION,

  PREFIX        = '/usr/local',
  INST_LIBDIR   = '$PREFIX/lib/lua/$LUAVERSION',
  INST_LUADIR   = '$PREFIX/share/lua/$LUAVERSION',

  LUA_INCDIR    = '/usr/include/lua$LUAVERSION',

  LIB_EXTENSION = 'so',
  OBJ_EXTENSION = 'o',

  INSTALL       = 'cp',
  MAKEDIRS      = 'mkdir -p',

  COMPILE       = '$CC $CFLAGS $LIBFLAGS $PKGFLAGS $CPPFLAGS',
  CFLAGS        = '-O2',
  platforms     = {
    macosx  = {
      LIBFLAGS  = '-fPIC -bundle -undefined dynamic_lookup -all_load',
    },
    LIBFLAGS    = '-shared -fPIC',
  },
}, SHELLENV)


local CONFIGENV = {
  compile  = '$CC -c $CFLAGS $CPPFLAGS',
  libs     = '',
  link     = '$CC -o conftest $CFLAGS $CPPFLAGS $LDFLAGS',
}




--[[ ========== ]]--
--[[ Configury. ]]--
--[[ ========== ]]--


local function interpolate(env, s)
  local r = ''
  while r ~= s do
    r = s
    s = gsub(r, '%$([%w_]+)', function(varname)
      return env[varname] or ''
    end)
  end
  return r
end


local function spawn(env, ...)
  local out, err = tmpname(), tmpname()
  local cmd = concat {
    interpolate(env, concat({...}, ' ')), ' >', out, ' 2>', err, '; printf $?'
  }
  return int(slurp(Pipe(cmd))), slurp(File(err)), slurp(File(out))
end


local verbose = nop


local configure
do
  local function checking(...)
    verbose('checking ', concat({...}, ' '), '... ')
  end


  local function found_library(x)
    if x == nil or x == '' then
      verbose 'none required'
    else
      verbose(x)
    end
    verbose '\n'
    return x
  end


  local function found_prog(x)
    verbose(x ~= nil and 'yes\n' or 'no\n')
    return x
  end


  local function found_result(x)
    verbose(x == 1 and 'yes\n' or 'no\n')
    return x
  end


  local function check_executable_in_path(env, prog)
    local paths = {}
    gsub(getenv'PATH', '[^:]+', function(path)
      append(paths, path)
    end)
    for path in each(paths) do
      local h = open(path .. '/' .. prog, 'r')
      if isfile(h) then
        h:close()
        return prog
      end
    end
  end


  local function check_header_compile(env, header, extra_hdrs)
    return with(TmpFile('conftest.c', 'w'), function(conftest)
      conftest:write(format('%s\n#include "%s"\n', extra_hdrs, header))
      return 0 == spawn(env, '$compile conftest.c') and 1 or 0
    end)
  end


  local function try_link(env, lib, symbol)
    return with(TmpFile('conftest.c', 'w'), function(conftest)
      conftest:write(format([[
/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
char %s ();
int main () {
  return %s ();
}
]], symbol, symbol))
      return spawn(env, '$link conftest.c', lib)
    end)
  end


  local function check_func_decl(env, fname, extra_hdrs)
    return with(TmpFile('conftest.c', 'w'), function(conftest)
      conftest:write(format([[
%s
int
main()
{
#ifndef %s
  (void) %s;
#endif
  return 0;
}
]], extra_hdrs, fname, fname))
      return 0 == spawn(env, '$compile conftest.c') and 1 or 0
    end)
  end


  local function check_func_link(env, fname)
    return with(TmpFile('conftest.c', 'w'), function(conftest)
      conftest:write(format([[
/* Define to an innocous variant, in case <limits.h> declares it.
   For example, HP-UX 11i <limits,h> declares gettimeofday.  */
#define %s innocuous_%s

/* System header to define __stub macros and hopefully few prototypes,
   which can conflict with declaration below.
   Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
   <limits.h> exists even on freestanding compilers.  */

#ifdef __STDC__
# include <limits.h>
#else
# include <assert.h>
#endif

#undef %s

/* Override any GCC internal prototype to avoid an error.
   Use char because int might match the return type of a GCC
   builtin and then its argument prototype would still apply.  */
char %s ();

/* The GNU C library defines this for functions which it implements
   to always fail with ENOSYS.  Some functions are actually named
   something starting with __ and the normal name is an alias.  */
#if defined __stub_%s || defined __stub__%s
choke me
#endif

int main () {
  return %s ();
}
]], fname, fname, fname, fname, fname, fname, fname))
      return spawn(env, '$link conftest.c $libs') == 0 and 1 or 0
    end)
  end


  configure = setmetatable(OrderedDict({
    checkprog = function(env, argv)
      for prog in each(argv.progs) do
        checking('for', prog)
        if found_prog(check_executable_in_path(env, prog)) then
          return prog
        end
      end
      if prog == nil then
        fatal('cannot find ' .. argv.checkprog)
      end
    end
  }, {
    checkheader = function(env, argv)
      checking('for', argv.checkheader)

      local extra_hdrs = map(argv.includes, function(include)
        return format('#include "%s"', include)
      end)
      return found_result(check_header_compile(env, argv.checkheader, concat(extra_hdrs, '\n')))
    end
  }, {
    checkdecl = function(env, argv)
      checking('whether', argv.checkdecl, 'is declared')

      local extra_hdrs = map(argv.includes, function(include)
        return format('#include "%s"', include)
      end)
      return found_result(check_func_decl(env, argv.checkdecl, concat(extra_hdrs, '\n')))
    end
  }, {
    searchlibs = function(env, argv)
      checking('for library containing', argv.symbol)

      local libraries, symbol = argv.searchlibs, argv.symbol
      local libs = {''}
      for lib in each(libraries) do
        append(libs, '-l' .. lib)
      end
      for lib in each(libs) do
        if try_link(env, lib, symbol) == 0 then
          if lib ~= '' then
            if CONFIGENV.libs ~= '' then
              CONFIGENV.libs = CONFIGENV.libs .. ' '
            end
            CONFIGENV.libs = CONFIGENV.libs .. lib
          end
          return found_library(lib)
        end
      end

      verbose '\n'
      libraries[1] = 'c'
      fatal("required symbol '%s' not found in any of lib%s",
        symbol, concat(libraries, ', lib'))
    end
  }, {
    checkfunc = function(env, argv)
      checking('for', argv.checkfunc)
      return found_result(check_func_link(env, argv.checkfunc))
    end
  }), {
    __call = function(self, env, v)
      return case(type(v), {
        ['number'] = function()
          return str(v)
        end,

        ['string'] = function()
          return v
        end,

        ['table'] = function()
          for fname in each(self) do
            if v[fname] ~= nil then
              return apply(self[fname], {env, v})
            end
          end
          fatal("unable to configure with keys '%s'",
            concat(keys(v), "', '"))
        end,

        function(type)
          fatal("unsupported configure type '%s'", type)
        end,
      })
    end,
  })
end


local function config_compiler(env)
  if env.CC == nil then
    local cc = {'cc', 'gcc', 'clang'}
    DEFAULTENV.CC = configure(env, {checkprog='C compiler', progs=cc})
  end

  verbose(interpolate(env, 'checking whether $CC works...'))
  local works, err = with(TmpFile('conftest.c', 'w'), function(conftest)
    conftest:write('typedef int x;\n')
    return spawn(env, '$compile conftest.c')
  end)
  if works ~= 0 then
    verbose 'no\n'
    stderr:write(err .. '\n')
    exit(1)
  end
  verbose 'yes\n'
end


local function defines(env, t)
  local buf = {}
  for var, val in next, t or {} do
    local v = configure(env, val)
    if int(v) == 1 then
      append(buf, '-D' .. var)
    else
      if match(v, '[%s"%$]') ~= nil then
        v = "'" .. v .. "'"
      end
      append(buf, '-D' .. var .. "=" .. v)
    end
  end
  return concat(buf, ' ')
end


local function includes(env, t)
  if t == nil then
    return ''
  end
  return '-I' .. concat(t, ' -I')
end


local function libraries(env, t)
  local buf = map(t, bind(configure, {env}))
  return concat(buf, ' ')
end



--[[ ============== ]]--
--[[ Load Lukefile. ]]--
--[[ ============== ]]--


local function has_key(t, k)
  return t[k] ~= nil
end


local function has_anykey(t, keylist)
  return any(map(keylist, function(k)
    return has_key(t, k)
  end))
end


local function isconfig(x)
  return istable(x) and has_anykey(x, configure)
end


local function collect_configs(luke, modulename, configs)
  configs = configs or {}
  for k, v in next, luke do
    if isconfig(v) then
      append(configs, {t=luke, k=k, module=modulename})
    elseif istable(v) then
      if k == 'modules' then
        for name, rules in next, v do
          collect_configs(rules, name, configs)
        end
      else
        collect_configs(v, modulename, configs)
      end
    end
  end
  return configs
end


-- Sort according to the key order in configure itself.
local weighting = setmetatable(copy(configure), {
  __call = function(self, config)
    local t = config.t[config.k]
    for i = 1, len(self) do
      if t[self[i]] ~= nil then
        return i
      end
    end
  end
})


local function config_cmp(a, b)
  return weighting(a) < weighting(b)
end
  

local function run_configs(env, luke, targets)
  local all_configs = collect_configs(luke)
  sort(all_configs, config_cmp)
  for config in each(all_configs) do
    t = config.t[config.k]
    if config.module == nil or contains(targets, config.module) then
      config.t[config.k] = configure(env, t)
    end
  end
end


local function normalize_configs(config)
  return cond({
    [not istable(config)] = config
  }, {
    [not isconfig(config)] = function()
      return mapvalues(config, normalize_configs)
    end
  }, {
    [true] = function()
      local seqkeys = {'includes', 'progs', 'searchlibs'}
      local r = mapvalues(collect(seqkeys, config), function(v)
        return isstring(v) and {v} or v
      end)
      return merge(r, config)
    end
  })
end


local function normalize_rules(rules)
  return case(type(rules), {
    ['string'] = function()
      return {sources={rules}}
    end,

    ['table'] = function()
      if len(rules) > 0 then
        return {sources=rules}
      elseif isstring(rules.sources) then
        return merge({sources = {rules.sources}}, normalize_configs(rules))
      end
      return normalize_configs(rules)
    end,

    function(v)
      fatal("unsupported rule type '%s'", v)
    end,
  })
end


local function loadluke(filename)
  local content, err = slurp(File(filename))
  if content == nil then
    return nil, err
  end
  local r = {}
  local chunk, err = loadstring(content, filename, r)
  if chunk == nil then
    return nil, "Error loading file: " .. err
  end
  local ok, err = pcall(chunk)
  if not ok then
    return nil, "Error running file: " .. err
  end
  r = filter_platforms(r)
  for module in each(keys(r.modules)) do
    r.modules[module] = normalize_rules(r.modules[module])
  end
  return r
end



--[[ ================ ]]--
--[[ Parse Arguments. ]]--
--[[ ================ ]]--


local function version()
  print [[
luke (Luke) 0.0.0
Written by Gary V. Vaughan <gary@gnu.org>, 2014

Copyright (C) 2016, Gary V. Vaughan
Luke comes with ABSOLUTELY NO WARRANTY.
You may redistribute copies of Luke under the terms of the MIT license;
it may be used for any purpose at absolutely no cost, without permission.
See <https://mit-license.org> for details.
]]
  exit(0)
end


local function help()
  print [[
Usage: luke [OPTION]... [VAR=VALUE]... [TARGET]

Use the source, Luke!

  --help        print this help, then exit
  --version     print version number, then exit
  --file=FILE   use FILE instead of lukefile
  --quiet       without any output
  --verbose     provide more progress output

Each TARGET can be one of the module table keys from lukefile, or:

  all           build all targets in lukefile
  install       copy all built targets to $PREFIX

If no TARGET is given, 'all' is implied.

Report bugs to https://github.com/gvvaughan/luke/issues.]]
  exit(0)
end


local function opterr(msg)
  if match(msg, '%.$') == nil then
    msg = msg .. '.'
  end
  stderr:write('luke: error: ' .. msg .. '\n')
  stderr:write("luke: try '" .. arg[0] .. " --help' for help.\n")
  exit(2)
end


local function parse_arguments(args)
  local clidefs, fname, targets = {}, 'lukefile', {}

  map(args, function(opt)
    case(opt, {
      ['--file=(.+)'] = function(optarg)
        fname = optarg
      end,

      ['--quiet'] = function()
        print = nop
      end,

      ['--verbose'] = function()
        verbose = function(...)
          stdout:write(concat{...})
        end
      end,

      ['--help'] = help,

      ['--version'] = version,

      ['(.+)=(.+)'] = function(name, value)
        clidefs[name] = value
      end,

      function(opt)
        if match(opt, '^-') ~= nil then
          opterr(format("unrecognized option '%s'", opt))
        end
        append(targets, opt)
      end,
    })
  end)


  local luke, err = loadluke(fname)
  if luke == nil then
    fatal('bad ' .. fname .. ': ' .. err)
  end

  if isempty(luke.modules or {}) then
    fatal("no modules table in '%s', nothing to build", args.file)
  end

  targets = call(function()
    if isempty(targets) or contains(targets, 'all') then
      return keys(luke.modules)
    end
    local r = filter(targets, function(target)
      if target ~= 'install' and luke.modules[target] == nil then
        fatal("no rule to make target '%s'", target)
      end
      return true
    end)
    assert(len(r) > 0, "no build targets specified")
    return r
  end)

  return {
    clidefs = clidefs,
    luke    = luke,
    targets = targets,
  }
end



--[[ ===== ]]--
--[[ Main. ]]--
--[[ ===== ]]--


local function run(env, command)
  print(interpolate(env, concat(command, ' ')))
  local status, err, out = spawn(env, unpack(command))
  if status ~= 0 then
    if print == nop then
      stdout:write(concat(command, ' ') .. '\n')
    end
    stderr:write(err .. '\n')
  end
  return status, out, err
end


local function build_c_module(env, luke, module)
  local rules = luke.modules[module]

  local command = {
    '$COMPILE',
    defines(env, rules.defines),
    defines(env, luke.defines),
    includes(env, rules.includes),
    includes(env, luke.includes),
  }
  map(rules.sources, bind(append, {command}))
  append(command, '-o')
  append(command, luke.variables.objdir
    .. '/'
    .. gsub(module, '%.', '/')
    .. '.$LIB_EXTENSION'
  )
  append(command, "$LIBS")
  append(command, libraries(env, rules.libraries))
  return run(env, command)
end


local function module_to_path(luke, module, rules)
  for source in each(rules.sources) do
    return case(source, {
      ['.*%.lua'] = function(src)
        local abspath = '$INST_LUADIR/' .. gsub(module, '%.', '/')
        if match(src, '/init%.lua$') then
          abspath = abspath .. '/init'
        end
        abspath = abspath .. '.lua'
        return src, (gsub(abspath, '/[^/]+%.lua$', ''))
      end,

      ['.*%.[ch]'] = function()
        local path = gsub(module, '%.', '/')
        local src = luke.variables.objdir .. '/' .. path .. '.$LIB_EXTENSION'
        return src, (gsub('$INST_LIBDIR/' .. path, '/[^/]+$', ''))
      end,

      function(src)
        fatal("unsupported source type '%s'", src)
      end,
    })
  end
end


local function install_modules(env, luke, modules)
  for module, rules in next, modules do
    local src, dir = module_to_path(luke, module, rules)
    local status = 0
    if open(interpolate(env, dir)) == nil then
      status = run(env, {'$MAKEDIRS', dir})
    end
    if status == 0 then
      status = run(env, {'$INSTALL', src, dir .. '/'})
    end
  end
  return 0
end


local function c_modules(modules, targets)
  return filter(targets, function(target)
    if modules[target] then
      local rules = modules[target]
      for f in each(rules.sources) do
        if match(f, '%.[ch]$') then
          return true
        end
      end
    end
    return false
  end)
end


local function main()
  local L    = parse_arguments(arg)
  local c    = c_modules(L.luke.modules, L.targets)
  local env  = pushenv(L.clidefs, pushenv(L.luke.variables, DEFAULTENV))
  local conf = pushenv(CONFIGENV, env)

  if len(c) > 0 then
    config_compiler(conf)
  end
  run_configs(conf, L.luke, L.targets)

  local status = 0
  for module in each(c) do
    status = build_c_module(env, L.luke, module)
    if status ~= 0 then
      return status
    end
  end

  if contains(L.targets, 'install') then
    status = install_modules(env, L.luke, L.luke.modules)
  end

  return status
end


exit(main())
